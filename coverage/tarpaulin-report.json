{"files":[{"path":["/","Users","martintrojer","hacking","thokr","src","language","core.rs"],"content":"use include_dir::{include_dir, Dir};\nuse serde::Deserialize;\nuse serde_json::from_str;\nuse std::error::Error;\n\nstatic LANG_DIR: Dir = include_dir!(\"src/lang\");\n\n#[allow(dead_code)]\n#[derive(Deserialize, Clone, Debug)]\npub struct Language {\n    pub name: String,\n    pub size: u32,\n    pub words: Vec<String>,\n}\n\nimpl Language {\n    pub fn new(file_name: String) -> Self {\n        read_language_from_file(format!(\"{}.json\", file_name)).unwrap()\n    }\n}\n\nfn read_language_from_file(file_name: String) -> Result<Language, Box<dyn Error>> {\n    let file = LANG_DIR\n        .get_file(file_name)\n        .expect(\"Language file not found\");\n\n    let file_as_str = file\n        .contents_utf8()\n        .expect(\"Unable to interpret file as a string\");\n\n    let lang = from_str(file_as_str).expect(\"Unable to deserialize language json\");\n\n    Ok(lang)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_language_new() {\n        let lang = Language::new(\"english\".to_string());\n\n        assert_eq!(lang.name, \"english\");\n        assert!(!lang.words.is_empty());\n        assert!(lang.size > 0);\n    }\n\n    #[test]\n    fn test_language_new_english1k() {\n        let lang = Language::new(\"english1k\".to_string());\n\n        assert_eq!(lang.name, \"english_1k\");\n        assert!(!lang.words.is_empty());\n        assert!(lang.size > 0);\n    }\n\n    #[test]\n    fn test_language_new_english10k() {\n        let lang = Language::new(\"english10k\".to_string());\n\n        assert_eq!(lang.name, \"english_10k\");\n        assert!(!lang.words.is_empty());\n        assert!(lang.size > 0);\n    }\n\n    #[test]\n    fn test_language_deserialization() {\n        let json_data = r#\"\n        {\n            \"name\": \"test\",\n            \"size\": 3,\n            \"words\": [\"hello\", \"world\", \"test\"]\n        }\n        \"#;\n\n        let lang: Language = from_str(json_data).expect(\"Failed to deserialize test language\");\n\n        assert_eq!(lang.name, \"test\");\n        assert_eq!(lang.size, 3);\n        assert_eq!(lang.words.len(), 3);\n        assert!(lang.words.contains(&\"hello\".to_string()));\n        assert!(lang.words.contains(&\"world\".to_string()));\n        assert!(lang.words.contains(&\"test\".to_string()));\n    }\n\n    #[test]\n    fn test_read_language_from_file() {\n        let result = read_language_from_file(\"english.json\".to_string());\n        assert!(result.is_ok());\n\n        let lang = result.unwrap();\n        assert_eq!(lang.name, \"english\");\n        assert!(!lang.words.is_empty());\n    }\n\n    #[test]\n    #[should_panic(expected = \"Language file not found\")]\n    fn test_read_nonexistent_language_file() {\n        let _result = read_language_from_file(\"nonexistent.json\".to_string());\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":38}},{"line":18,"address":[],"length":0,"stats":{"Line":38}},{"line":22,"address":[],"length":0,"stats":{"Line":40}},{"line":23,"address":[],"length":0,"stats":{"Line":40}},{"line":24,"address":[],"length":0,"stats":{"Line":40}},{"line":27,"address":[],"length":0,"stats":{"Line":40}},{"line":31,"address":[],"length":0,"stats":{"Line":40}},{"line":33,"address":[],"length":0,"stats":{"Line":40}}],"covered":8,"coverable":8},{"path":["/","Users","martintrojer","hacking","thokr","src","language","difficulty.rs"],"content":"/// Character difficulty metrics for intelligent word selection\n#[derive(Debug, Clone)]\npub struct CharacterDifficulty {\n    pub miss_rate: f64,      // Percentage of incorrect attempts (0-100) for any case\n    pub avg_time_ms: f64,    // Average time to type the character (any case)\n    pub total_attempts: i64, // Total number of attempts for weighting\n    // Uppercase-specific difficulty metrics\n    pub uppercase_miss_rate: f64, // Percentage of incorrect uppercase attempts (0-100)\n    pub uppercase_avg_time: f64,  // Average time for uppercase variants\n    pub uppercase_attempts: i64,  // Total uppercase attempts for weighting\n    pub uppercase_penalty: f64,   // Additional difficulty penalty for uppercase (0-1)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","martintrojer","hacking","thokr","src","language","formatter.rs"],"content":"use rand::seq::SliceRandom;\nuse rand::Rng;\n\n/// Trait for text formatting strategies\npub trait TextFormatter {\n    /// Format a list of words into a final string\n    fn format(&self, words: Vec<String>) -> String;\n}\n\n/// Basic formatter that just joins words with spaces\npub struct BasicFormatter;\n\nimpl TextFormatter for BasicFormatter {\n    fn format(&self, words: Vec<String>) -> String {\n        words.join(\" \")\n    }\n}\n\n/// Formatter that adds capitalization and punctuation\npub struct CapitalizationFormatter;\n\nimpl TextFormatter for CapitalizationFormatter {\n    fn format(&self, words: Vec<String>) -> String {\n        if words.is_empty() {\n            return String::new();\n        }\n\n        let rng = &mut rand::thread_rng();\n        let mut result = Vec::new();\n\n        for (i, word) in words.iter().enumerate() {\n            let mut formatted_word = word.clone();\n\n            // Capitalize first word and randomly capitalize others (20% chance)\n            if i == 0 || rng.gen_bool(0.2) {\n                formatted_word = capitalize_first_letter(&formatted_word);\n            }\n\n            result.push(formatted_word);\n\n            // Add commas between words (15% chance)\n            if i < words.len() - 1 && rng.gen_bool(0.15) {\n                result.push(\",\".to_string());\n            }\n        }\n\n        // Add final punctuation\n        let final_punct = match rng.gen_range(0..100) {\n            0..=79 => \".\",\n            80..=94 => \"!\",\n            _ => \"?\",\n        };\n        result.push(final_punct.to_string());\n\n        // Clean up spacing around punctuation\n        let mut text = result.join(\" \");\n        text = text.replace(\" ,\", \",\");\n        text = text.replace(\" .\", \".\");\n        text = text.replace(\" !\", \"!\");\n        text = text.replace(\" ?\", \"?\");\n        text\n    }\n}\n\n/// Formatter that adds symbols and special characters\npub struct SymbolFormatter;\n\nimpl TextFormatter for SymbolFormatter {\n    fn format(&self, words: Vec<String>) -> String {\n        if words.is_empty() {\n            return String::new();\n        }\n\n        let rng = &mut rand::thread_rng();\n        let mut result = Vec::new();\n\n        // Define symbol sets for different contexts\n        let mathematical = [\"+\", \"-\", \"*\", \"/\", \"=\", \"<\", \">\"];\n        let programming = [\"@\", \"#\", \"$\", \"%\", \"^\", \"&\", \"|\", \"\\\\\", \"~\", \"`\"];\n        let punctuation_symbols = [\":\", \";\", \"\\\"\", \"'\"];\n\n        for (i, word) in words.iter().enumerate() {\n            let mut formatted_word = word.clone();\n\n            // Add symbols around words (25% chance)\n            if rng.gen_bool(0.25) {\n                let symbol_type = rng.gen_range(0..4);\n                match symbol_type {\n                    0 => {\n                        // Brackets - always paired\n                        let bracket_pair = rng.gen_range(0..3);\n                        match bracket_pair {\n                            0 => formatted_word = format!(\"({})\", formatted_word),\n                            1 => formatted_word = format!(\"[{}]\", formatted_word),\n                            _ => formatted_word = format!(\"{{{}}}\", formatted_word),\n                        }\n                    }\n                    1 => {\n                        // Mathematical symbols - prefix or suffix\n                        let symbol = mathematical.choose(rng).unwrap();\n                        if rng.gen_bool(0.5) {\n                            formatted_word = format!(\"{}{}\", symbol, formatted_word);\n                        } else {\n                            formatted_word = format!(\"{}{}\", formatted_word, symbol);\n                        }\n                    }\n                    2 => {\n                        // Programming symbols - usually prefix\n                        let symbol = programming.choose(rng).unwrap();\n                        formatted_word = format!(\"{}{}\", symbol, formatted_word);\n                    }\n                    _ => {\n                        // Punctuation symbols - usually suffix\n                        let symbol = punctuation_symbols.choose(rng).unwrap();\n                        formatted_word = format!(\"{}{}\", formatted_word, symbol);\n                    }\n                }\n            }\n\n            result.push(formatted_word);\n\n            // Add special separators between words (20% chance)\n            if i < words.len() - 1 {\n                let separator_choice = rng.gen_range(0..10);\n                match separator_choice {\n                    0 => result.push(\",\".to_string()),\n                    1 => result.push(\";\".to_string()),\n                    _ => {} // Just space\n                }\n            }\n        }\n\n        // Add final punctuation with more variety\n        let final_punct = match rng.gen_range(0..100) {\n            0..=50 => \".\",\n            51..=65 => \"!\",\n            66..=75 => \"?\",\n            76..=85 => \";\",\n            86..=92 => \":\",\n            _ => \"...\",\n        };\n        result.push(final_punct.to_string());\n\n        // Clean up spacing around punctuation\n        let mut text = result.join(\" \");\n        text = text.replace(\" ,\", \",\");\n        text = text.replace(\" .\", \".\");\n        text = text.replace(\" !\", \"!\");\n        text = text.replace(\" ?\", \"?\");\n        text = text.replace(\" ;\", \";\");\n        text = text.replace(\" :\", \":\");\n        text\n    }\n}\n\n/// Composite formatter that combines multiple formatters\npub struct CompositeFormatter {\n    formatters: Vec<Box<dyn TextFormatter>>,\n}\n\nimpl Default for CompositeFormatter {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl CompositeFormatter {\n    pub fn new() -> Self {\n        Self {\n            formatters: Vec::new(),\n        }\n    }\n\n    pub fn add_formatter(mut self, formatter: Box<dyn TextFormatter>) -> Self {\n        self.formatters.push(formatter);\n        self\n    }\n\n    pub fn build_from_flags(\n        include_capitalize: bool,\n        include_symbols: bool,\n    ) -> Box<dyn TextFormatter> {\n        if !include_capitalize && !include_symbols {\n            return Box::new(BasicFormatter);\n        }\n\n        let mut composite = CompositeFormatter::new();\n\n        if include_capitalize && include_symbols {\n            // For combined formatting, use the original advanced formatting logic\n            composite = composite.add_formatter(Box::new(CombinedFormatter));\n        } else if include_capitalize {\n            composite = composite.add_formatter(Box::new(CapitalizationFormatter));\n        } else if include_symbols {\n            composite = composite.add_formatter(Box::new(SymbolFormatter));\n        }\n\n        Box::new(composite)\n    }\n}\n\nimpl TextFormatter for CompositeFormatter {\n    fn format(&self, words: Vec<String>) -> String {\n        // Apply formatters in sequence\n        self.formatters\n            .iter()\n            .fold(words, |current_words, formatter| {\n                // For sequential application, we need to split the formatted text back to words\n                // This is a simplification - in practice, you might want more sophisticated chaining\n                let formatted = formatter.format(current_words);\n                vec![formatted]\n            })\n            .into_iter()\n            .next()\n            .unwrap_or_default()\n    }\n}\n\n/// Combined formatter that handles both capitalization and symbols together\n/// (preserves the original advanced formatting behavior)\npub struct CombinedFormatter;\n\nimpl TextFormatter for CombinedFormatter {\n    fn format(&self, words: Vec<String>) -> String {\n        if words.is_empty() {\n            return String::new();\n        }\n\n        let rng = &mut rand::thread_rng();\n        let mut result = Vec::new();\n\n        // Define symbol sets for different contexts\n        let mathematical = [\"+\", \"-\", \"*\", \"/\", \"=\", \"<\", \">\"];\n        let programming = [\"@\", \"#\", \"$\", \"%\", \"^\", \"&\", \"|\", \"\\\\\", \"~\", \"`\"];\n        let punctuation_symbols = [\":\", \";\", \"\\\"\", \"'\"];\n\n        for (i, word) in words.iter().enumerate() {\n            let mut formatted_word = word.clone();\n\n            // Capitalize first word and randomly capitalize others (20% chance)\n            if i == 0 || rng.gen_bool(0.2) {\n                formatted_word = capitalize_first_letter(&formatted_word);\n            }\n\n            // Add symbols around words (25% chance)\n            if rng.gen_bool(0.25) {\n                let symbol_type = rng.gen_range(0..4);\n                match symbol_type {\n                    0 => {\n                        // Brackets - always paired\n                        let bracket_pair = rng.gen_range(0..3);\n                        match bracket_pair {\n                            0 => formatted_word = format!(\"({})\", formatted_word),\n                            1 => formatted_word = format!(\"[{}]\", formatted_word),\n                            _ => formatted_word = format!(\"{{{}}}\", formatted_word),\n                        }\n                    }\n                    1 => {\n                        // Mathematical symbols - prefix or suffix\n                        let symbol = mathematical.choose(rng).unwrap();\n                        if rng.gen_bool(0.5) {\n                            formatted_word = format!(\"{}{}\", symbol, formatted_word);\n                        } else {\n                            formatted_word = format!(\"{}{}\", formatted_word, symbol);\n                        }\n                    }\n                    2 => {\n                        // Programming symbols - usually prefix\n                        let symbol = programming.choose(rng).unwrap();\n                        formatted_word = format!(\"{}{}\", symbol, formatted_word);\n                    }\n                    _ => {\n                        // Punctuation symbols - usually suffix\n                        let symbol = punctuation_symbols.choose(rng).unwrap();\n                        formatted_word = format!(\"{}{}\", formatted_word, symbol);\n                    }\n                }\n            }\n\n            result.push(formatted_word);\n\n            // Add punctuation between words\n            if i < words.len() - 1 {\n                // With symbols enabled, more variety in separators (20% chance for special separator)\n                let separator_choice = rng.gen_range(0..10);\n                match separator_choice {\n                    0 => result.push(\",\".to_string()),\n                    1 => result.push(\";\".to_string()),\n                    _ => {} // Just space\n                }\n            }\n        }\n\n        // Add final punctuation with more variety\n        let final_punct = match rng.gen_range(0..100) {\n            0..=50 => \".\",\n            51..=65 => \"!\",\n            66..=75 => \"?\",\n            76..=85 => \";\",\n            86..=92 => \":\",\n            _ => \"...\",\n        };\n        result.push(final_punct.to_string());\n\n        // Clean up spacing around punctuation\n        let mut text = result.join(\" \");\n        text = text.replace(\" ,\", \",\");\n        text = text.replace(\" .\", \".\");\n        text = text.replace(\" !\", \"!\");\n        text = text.replace(\" ?\", \"?\");\n        text = text.replace(\" ;\", \";\");\n        text = text.replace(\" :\", \":\");\n        \n        // Ensure the first alphabetic character is capitalized\n        // This is a safety net to handle edge cases in the complex formatting logic\n        if let Some(first_alpha_pos) = text.chars().position(|c| c.is_alphabetic()) {\n            let mut chars: Vec<char> = text.chars().collect();\n            if let Some(first_alpha_char) = chars.get(first_alpha_pos) {\n                if first_alpha_char.is_lowercase() {\n                    chars[first_alpha_pos] = first_alpha_char.to_uppercase().next().unwrap_or(*first_alpha_char);\n                    text = chars.into_iter().collect();\n                }\n            }\n        }\n        \n        text\n    }\n}\n\n/// Helper function to capitalize the first letter of a word\nfn capitalize_first_letter(word: &str) -> String {\n    let mut chars: Vec<char> = word.chars().collect();\n    if !chars.is_empty() && chars[0].is_alphabetic() {\n        chars[0] = chars[0].to_uppercase().next().unwrap_or(chars[0]);\n    }\n    chars.into_iter().collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_basic_formatter() {\n        let formatter = BasicFormatter;\n        let words = vec![\"hello\".to_string(), \"world\".to_string()];\n\n        let result = formatter.format(words);\n        assert_eq!(result, \"hello world\");\n    }\n\n    #[test]\n    fn test_capitalization_formatter() {\n        let formatter = CapitalizationFormatter;\n        let words = vec![\"hello\".to_string(), \"world\".to_string()];\n\n        let result = formatter.format(words);\n\n        // Should start with capital letter\n        assert!(result.chars().next().unwrap().is_uppercase());\n        // Should end with punctuation\n        assert!(result.ends_with('.') || result.ends_with('!') || result.ends_with('?'));\n    }\n\n    #[test]\n    fn test_symbol_formatter() {\n        let formatter = SymbolFormatter;\n        let words = vec![\"hello\".to_string(), \"world\".to_string()];\n\n        let result = formatter.format(words);\n\n        // Should end with punctuation\n        assert!(\n            result.ends_with('.')\n                || result.ends_with('!')\n                || result.ends_with('?')\n                || result.ends_with(';')\n                || result.ends_with(':')\n                || result.ends_with(\"...\")\n        );\n        // Should contain the original words\n        let lowercase_result = result.to_lowercase();\n        assert!(lowercase_result.contains(\"hello\"));\n        assert!(lowercase_result.contains(\"world\"));\n    }\n\n    #[test]\n    fn test_composite_formatter_build_from_flags() {\n        let words = vec![\"hello\".to_string(), \"world\".to_string()];\n\n        // Test basic (no flags)\n        let basic_formatter = CompositeFormatter::build_from_flags(false, false);\n        let basic_result = basic_formatter.format(words.clone());\n        assert_eq!(basic_result, \"hello world\");\n\n        // Test capitalization only\n        let cap_formatter = CompositeFormatter::build_from_flags(true, false);\n        let cap_result = cap_formatter.format(words.clone());\n        assert!(cap_result.chars().next().unwrap().is_uppercase());\n\n        // Test symbols only\n        let sym_formatter = CompositeFormatter::build_from_flags(false, true);\n        let sym_result = sym_formatter.format(words.clone());\n        assert!(!sym_result.is_empty());\n\n        // Test combined\n        let combined_formatter = CompositeFormatter::build_from_flags(true, true);\n        let combined_result = combined_formatter.format(words);\n        // Should have capitalization (first alphabetic character should be uppercase)\n        let first_alpha_char = combined_result.chars().find(|c| c.is_alphabetic());\n        if let Some(first_char) = first_alpha_char {\n            assert!(first_char.is_uppercase());\n        }\n    }\n\n    #[test]\n    fn test_capitalize_first_letter() {\n        assert_eq!(capitalize_first_letter(\"hello\"), \"Hello\");\n        assert_eq!(capitalize_first_letter(\"WORLD\"), \"WORLD\");\n        assert_eq!(capitalize_first_letter(\"test123\"), \"Test123\");\n        assert_eq!(capitalize_first_letter(\"\"), \"\");\n        assert_eq!(capitalize_first_letter(\"123abc\"), \"123abc\");\n    }\n\n    #[test]\n    fn test_formatters_with_empty_input() {\n        let empty_words = vec![];\n\n        assert_eq!(BasicFormatter.format(empty_words.clone()), \"\");\n        assert_eq!(CapitalizationFormatter.format(empty_words.clone()), \"\");\n        assert_eq!(SymbolFormatter.format(empty_words.clone()), \"\");\n    }\n\n    #[test]\n    fn test_formatters_with_single_word() {\n        let single_word = vec![\"test\".to_string()];\n\n        let basic_result = BasicFormatter.format(single_word.clone());\n        assert_eq!(basic_result, \"test\");\n\n        let cap_result = CapitalizationFormatter.format(single_word.clone());\n        assert!(cap_result.starts_with(\"Test\"));\n        assert!(\n            cap_result.ends_with('.') || cap_result.ends_with('!') || cap_result.ends_with('?')\n        );\n\n        let sym_result = SymbolFormatter.format(single_word);\n        assert!(!sym_result.is_empty());\n    }\n\n    #[test]\n    fn test_composite_formatter_new_and_add() {\n        let composite = CompositeFormatter::new().add_formatter(Box::new(BasicFormatter));\n\n        let words = vec![\"hello\".to_string(), \"world\".to_string()];\n        let result = composite.format(words);\n        assert_eq!(result, \"hello world\");\n    }\n\n    #[test]\n    fn test_combined_formatter_empty_input() {\n        let combined = CombinedFormatter;\n        let empty_words = vec![];\n\n        let result = combined.format(empty_words);\n        assert_eq!(result, \"\");\n    }\n\n    #[test]\n    fn test_combined_formatter_functionality() {\n        let combined = CombinedFormatter;\n        let words = vec![\"hello\".to_string(), \"world\".to_string()];\n\n        let result = combined.format(words);\n\n        // Should have capitalization (first alphabetic character should be uppercase)\n        let first_alpha_char = result.chars().find(|c| c.is_alphabetic());\n        if let Some(first_char) = first_alpha_char {\n            assert!(first_char.is_uppercase());\n        }\n        // Should end with punctuation\n        assert!(\n            result.ends_with('.')\n                || result.ends_with('!')\n                || result.ends_with('?')\n                || result.ends_with(';')\n                || result.ends_with(':')\n                || result.ends_with(\"...\")\n        );\n    }\n\n    #[test]\n    fn test_combined_formatter_capitalization_guaranteed() {\n        // Test that the first word is ALWAYS capitalized in CombinedFormatter\n        let combined = CombinedFormatter;\n        let words = vec![\"test\".to_string(), \"word\".to_string()];\n\n        // Test multiple times to ensure capitalization is consistent\n        for attempt in 0..100 {\n            let result = combined.format(words.clone());\n            \n            let first_alpha_char = result.chars().find(|c| c.is_alphabetic());\n            if let Some(first_char) = first_alpha_char {\n                assert!(\n                    first_char.is_uppercase(),\n                    \"First alphabetic character should ALWAYS be uppercase on attempt {}. Generated result: '{}'\",\n                    attempt,\n                    result\n                );\n            }\n        }\n    }\n\n    #[test] \n    fn test_combined_formatter_debug_comma_issue() {\n        // Try to reproduce the comma-at-beginning issue\n        let combined = CombinedFormatter;\n        let words = vec![\"ve\".to_string(), \"nt\".to_string(), \"ask\".to_string(), \"yany\".to_string(), \"i\".to_string()];\n\n        for attempt in 0..100 {\n            let result = combined.format(words.clone());\n            \n            // Check for comma at beginning\n            if result.starts_with(',') {\n                panic!(\"Found comma at beginning on attempt {}: '{}'\", attempt, result);\n            }\n            \n            // Check first alphabetic character\n            let first_alpha_char = result.chars().find(|c| c.is_alphabetic());\n            if let Some(first_char) = first_alpha_char {\n                assert!(\n                    first_char.is_uppercase(),\n                    \"First alphabetic character should be uppercase on attempt {}. Generated result: '{}'\",\n                    attempt,\n                    result\n                );\n            }\n        }\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":14}},{"line":15,"address":[],"length":0,"stats":{"Line":14}},{"line":23,"address":[],"length":0,"stats":{"Line":6}},{"line":24,"address":[],"length":0,"stats":{"Line":6}},{"line":25,"address":[],"length":0,"stats":{"Line":1}},{"line":28,"address":[],"length":0,"stats":{"Line":5}},{"line":29,"address":[],"length":0,"stats":{"Line":5}},{"line":31,"address":[],"length":0,"stats":{"Line":15}},{"line":35,"address":[],"length":0,"stats":{"Line":17}},{"line":36,"address":[],"length":0,"stats":{"Line":7}},{"line":42,"address":[],"length":0,"stats":{"Line":11}},{"line":43,"address":[],"length":0,"stats":{"Line":1}},{"line":49,"address":[],"length":0,"stats":{"Line":9}},{"line":50,"address":[],"length":0,"stats":{"Line":2}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":6}},{"line":70,"address":[],"length":0,"stats":{"Line":6}},{"line":71,"address":[],"length":0,"stats":{"Line":1}},{"line":74,"address":[],"length":0,"stats":{"Line":5}},{"line":75,"address":[],"length":0,"stats":{"Line":5}},{"line":78,"address":[],"length":0,"stats":{"Line":5}},{"line":79,"address":[],"length":0,"stats":{"Line":5}},{"line":80,"address":[],"length":0,"stats":{"Line":5}},{"line":82,"address":[],"length":0,"stats":{"Line":15}},{"line":87,"address":[],"length":0,"stats":{"Line":2}},{"line":88,"address":[],"length":0,"stats":{"Line":2}},{"line":91,"address":[],"length":0,"stats":{"Line":2}},{"line":92,"address":[],"length":0,"stats":{"Line":2}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":1}},{"line":95,"address":[],"length":0,"stats":{"Line":1}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":10}},{"line":125,"address":[],"length":0,"stats":{"Line":10}},{"line":126,"address":[],"length":0,"stats":{"Line":2}},{"line":127,"address":[],"length":0,"stats":{"Line":1}},{"line":128,"address":[],"length":0,"stats":{"Line":7}},{"line":135,"address":[],"length":0,"stats":{"Line":8}},{"line":136,"address":[],"length":0,"stats":{"Line":2}},{"line":137,"address":[],"length":0,"stats":{"Line":3}},{"line":138,"address":[],"length":0,"stats":{"Line":1}},{"line":139,"address":[],"length":0,"stats":{"Line":2}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":10}},{"line":170,"address":[],"length":0,"stats":{"Line":10}},{"line":174,"address":[],"length":0,"stats":{"Line":10}},{"line":175,"address":[],"length":0,"stats":{"Line":10}},{"line":176,"address":[],"length":0,"stats":{"Line":10}},{"line":179,"address":[],"length":0,"stats":{"Line":19}},{"line":183,"address":[],"length":0,"stats":{"Line":32}},{"line":184,"address":[],"length":0,"stats":{"Line":10}},{"line":187,"address":[],"length":0,"stats":{"Line":9}},{"line":189,"address":[],"length":0,"stats":{"Line":18}},{"line":191,"address":[],"length":0,"stats":{"Line":3}},{"line":192,"address":[],"length":0,"stats":{"Line":12}},{"line":193,"address":[],"length":0,"stats":{"Line":3}},{"line":194,"address":[],"length":0,"stats":{"Line":9}},{"line":195,"address":[],"length":0,"stats":{"Line":3}},{"line":198,"address":[],"length":0,"stats":{"Line":9}},{"line":203,"address":[],"length":0,"stats":{"Line":10}},{"line":205,"address":[],"length":0,"stats":{"Line":10}},{"line":207,"address":[],"length":0,"stats":{"Line":20}},{"line":210,"address":[],"length":0,"stats":{"Line":10}},{"line":211,"address":[],"length":0,"stats":{"Line":10}},{"line":224,"address":[],"length":0,"stats":{"Line":205}},{"line":225,"address":[],"length":0,"stats":{"Line":205}},{"line":226,"address":[],"length":0,"stats":{"Line":1}},{"line":229,"address":[],"length":0,"stats":{"Line":204}},{"line":230,"address":[],"length":0,"stats":{"Line":204}},{"line":233,"address":[],"length":0,"stats":{"Line":204}},{"line":234,"address":[],"length":0,"stats":{"Line":204}},{"line":235,"address":[],"length":0,"stats":{"Line":204}},{"line":237,"address":[],"length":0,"stats":{"Line":714}},{"line":241,"address":[],"length":0,"stats":{"Line":813}},{"line":242,"address":[],"length":0,"stats":{"Line":303}},{"line":247,"address":[],"length":0,"stats":{"Line":182}},{"line":248,"address":[],"length":0,"stats":{"Line":182}},{"line":251,"address":[],"length":0,"stats":{"Line":40}},{"line":252,"address":[],"length":0,"stats":{"Line":40}},{"line":253,"address":[],"length":0,"stats":{"Line":12}},{"line":254,"address":[],"length":0,"stats":{"Line":16}},{"line":255,"address":[],"length":0,"stats":{"Line":12}},{"line":260,"address":[],"length":0,"stats":{"Line":47}},{"line":261,"address":[],"length":0,"stats":{"Line":70}},{"line":262,"address":[],"length":0,"stats":{"Line":23}},{"line":264,"address":[],"length":0,"stats":{"Line":24}},{"line":267,"address":[],"length":0,"stats":{"Line":45}},{"line":269,"address":[],"length":0,"stats":{"Line":45}},{"line":270,"address":[],"length":0,"stats":{"Line":45}},{"line":272,"address":[],"length":0,"stats":{"Line":50}},{"line":274,"address":[],"length":0,"stats":{"Line":50}},{"line":275,"address":[],"length":0,"stats":{"Line":50}},{"line":285,"address":[],"length":0,"stats":{"Line":510}},{"line":286,"address":[],"length":0,"stats":{"Line":510}},{"line":287,"address":[],"length":0,"stats":{"Line":35}},{"line":288,"address":[],"length":0,"stats":{"Line":53}},{"line":289,"address":[],"length":0,"stats":{"Line":422}},{"line":296,"address":[],"length":0,"stats":{"Line":315}},{"line":297,"address":[],"length":0,"stats":{"Line":125}},{"line":298,"address":[],"length":0,"stats":{"Line":76}},{"line":299,"address":[],"length":0,"stats":{"Line":67}},{"line":300,"address":[],"length":0,"stats":{"Line":36}},{"line":301,"address":[],"length":0,"stats":{"Line":14}},{"line":316,"address":[],"length":0,"stats":{"Line":440}},{"line":318,"address":[],"length":0,"stats":{"Line":204}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":315}},{"line":332,"address":[],"length":0,"stats":{"Line":315}},{"line":333,"address":[],"length":0,"stats":{"Line":942}},{"line":334,"address":[],"length":0,"stats":{"Line":313}},{"line":336,"address":[],"length":0,"stats":{"Line":315}}],"covered":106,"coverable":124},{"path":["/","Users","martintrojer","hacking","thokr","src","language","formatting.rs"],"content":"use super::core::Language;\nuse rand::seq::SliceRandom;\nuse rand::Rng;\n\nimpl Language {\n    /// Apply capitalization, punctuation, commas, and optionally symbols to words for realistic typing practice\n    pub fn apply_advanced_formatting(\n        &self,\n        words: Vec<String>,\n        include_capitalize: bool,\n        include_symbols: bool,\n    ) -> String {\n        if words.is_empty() {\n            return String::new();\n        }\n\n        let rng = &mut rand::thread_rng();\n        let mut result = Vec::new();\n\n        // Define symbol sets for different contexts\n        let mathematical = [\"+\", \"-\", \"*\", \"/\", \"=\", \"<\", \">\"];\n        let programming = [\"@\", \"#\", \"$\", \"%\", \"^\", \"&\", \"|\", \"\\\\\", \"~\", \"`\"];\n        let punctuation_symbols = [\":\", \";\", \"\\\"\", \"'\"];\n\n        for (i, word) in words.iter().enumerate() {\n            let mut formatted_word = word.clone();\n\n            // Capitalize first word and randomly capitalize others (20% chance) if capitalize is enabled\n            if include_capitalize && (i == 0 || rng.gen_bool(0.2)) {\n                formatted_word = Self::capitalize_first_letter(&formatted_word);\n            }\n\n            // Add symbols around words if symbols are enabled\n            if include_symbols {\n                // 25% chance to add symbols around words\n                if rng.gen_bool(0.25) {\n                    let symbol_type = rng.gen_range(0..4);\n                    match symbol_type {\n                        0 => {\n                            // Brackets - always paired\n                            let bracket_pair = rng.gen_range(0..3);\n                            match bracket_pair {\n                                0 => formatted_word = format!(\"({})\", formatted_word),\n                                1 => formatted_word = format!(\"[{}]\", formatted_word),\n                                _ => formatted_word = format!(\"{{{}}}\", formatted_word),\n                            }\n                        }\n                        1 => {\n                            // Mathematical symbols - prefix or suffix\n                            let symbol = mathematical.choose(rng).unwrap();\n                            if rng.gen_bool(0.5) {\n                                formatted_word = format!(\"{}{}\", symbol, formatted_word);\n                            } else {\n                                formatted_word = format!(\"{}{}\", formatted_word, symbol);\n                            }\n                        }\n                        2 => {\n                            // Programming symbols - usually prefix\n                            let symbol = programming.choose(rng).unwrap();\n                            formatted_word = format!(\"{}{}\", symbol, formatted_word);\n                        }\n                        _ => {\n                            // Punctuation symbols - usually suffix\n                            let symbol = punctuation_symbols.choose(rng).unwrap();\n                            formatted_word = format!(\"{}{}\", formatted_word, symbol);\n                        }\n                    }\n                }\n            }\n\n            result.push(formatted_word);\n\n            // Add punctuation between words\n            if i < words.len() - 1 {\n                if include_symbols {\n                    // With symbols enabled, more variety in separators (20% chance for special separator)\n                    let separator_choice = rng.gen_range(0..10);\n                    match separator_choice {\n                        0 => result.push(\",\".to_string()),\n                        1 => result.push(\";\".to_string()),\n                        _ => {} // Just space\n                    }\n                } else {\n                    // Original behavior: 15% chance for comma\n                    if rng.gen_bool(0.15) {\n                        result.push(\",\".to_string());\n                    }\n                }\n            }\n        }\n\n        // Add final punctuation\n        if include_symbols {\n            // More variety with symbols enabled\n            let final_punct = match rng.gen_range(0..100) {\n                0..=50 => \".\",\n                51..=65 => \"!\",\n                66..=75 => \"?\",\n                76..=85 => \";\",\n                86..=92 => \":\",\n                _ => \"...\",\n            };\n            result.push(final_punct.to_string());\n        } else {\n            // Original behavior\n            let final_punct = match rng.gen_range(0..100) {\n                0..=79 => \".\",\n                80..=94 => \"!\",\n                _ => \"?\",\n            };\n            result.push(final_punct.to_string());\n        }\n\n        // Clean up spacing around punctuation\n        let mut text = result.join(\" \");\n        text = text.replace(\" ,\", \",\");\n        text = text.replace(\" .\", \".\");\n        text = text.replace(\" !\", \"!\");\n        text = text.replace(\" ?\", \"?\");\n        text = text.replace(\" ;\", \";\");\n        text = text.replace(\" :\", \":\");\n        text\n    }\n\n    /// Helper function to capitalize the first letter of a word\n    fn capitalize_first_letter(word: &str) -> String {\n        let mut chars: Vec<char> = word.chars().collect();\n        if !chars.is_empty() && chars[0].is_alphabetic() {\n            chars[0] = chars[0].to_uppercase().next().unwrap_or(chars[0]);\n        }\n        chars.into_iter().collect()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_apply_advanced_formatting_basic() {\n        let lang = Language::new(\"english\".to_string());\n        let words = vec![\"hello\".to_string(), \"world\".to_string(), \"test\".to_string()];\n\n        let result = lang.apply_advanced_formatting(words, true, false);\n\n        // Should have capitalized first word and end with punctuation\n        assert!(result.starts_with(\"Hello\"));\n        assert!(result.ends_with('.') || result.ends_with('!') || result.ends_with('?'));\n        // Check that the base words are present (case-insensitive)\n        let lowercase_result = result.to_lowercase();\n        assert!(lowercase_result.contains(\"world\"));\n        assert!(lowercase_result.contains(\"test\"));\n    }\n\n    #[test]\n    fn test_capitalize_first_letter() {\n        assert_eq!(Language::capitalize_first_letter(\"hello\"), \"Hello\");\n        assert_eq!(Language::capitalize_first_letter(\"WORLD\"), \"WORLD\");\n        assert_eq!(Language::capitalize_first_letter(\"test123\"), \"Test123\");\n        assert_eq!(Language::capitalize_first_letter(\"\"), \"\");\n        assert_eq!(Language::capitalize_first_letter(\"123abc\"), \"123abc\");\n    }\n\n    #[test]\n    fn test_flag_independence_capitalize_only() {\n        let lang = Language::new(\"english\".to_string());\n        let words = vec![\"hello\".to_string(), \"world\".to_string()];\n\n        let result = lang.apply_advanced_formatting(words, true, false);\n\n        // Should have capitalization\n        assert!(result.chars().next().unwrap().is_uppercase());\n\n        // Should NOT have symbols (only basic punctuation at end)\n        let symbol_chars = \"@#$%^&*()[]{}|\\\\~`+-=<>\";\n        // Allow symbols only at the very end (final punctuation)\n        let main_content = &result[..result.len() - 1]; // Remove final punctuation\n        let has_symbols_in_main = main_content.chars().any(|c| symbol_chars.contains(c));\n        assert!(\n            !has_symbols_in_main,\n            \"Should not have symbols in main content with capitalize only\"\n        );\n    }\n\n    #[test]\n    fn test_flag_independence_symbols_only() {\n        let lang = Language::new(\"english\".to_string());\n        let words = vec![\"hello\".to_string(), \"world\".to_string()];\n\n        let result = lang.apply_advanced_formatting(words.clone(), false, true);\n\n        // Should NOT have capitalization (except potentially from symbols)\n        // But basic words should remain lowercase\n        let lowercase_result = result.to_lowercase();\n        assert!(lowercase_result.contains(\"hello\"));\n        assert!(lowercase_result.contains(\"world\"));\n\n        // Should potentially have symbols (due to 25% chance, run multiple times)\n        let mut _found_symbols = false;\n        for _ in 0..10 {\n            let test_result = lang.apply_advanced_formatting(words.clone(), false, true);\n            let symbol_chars = \"@#$%^&*()[]{}|\\\\~`+-=<>\";\n            if test_result.chars().any(|c| symbol_chars.contains(c)) {\n                _found_symbols = true;\n                break;\n            }\n        }\n        // Note: Due to randomness, we can't guarantee symbols, but the function should support them\n    }\n\n    #[test]\n    fn test_flag_independence_neither() {\n        let lang = Language::new(\"english\".to_string());\n        let words = vec![\"hello\".to_string(), \"world\".to_string()];\n\n        let result = lang.apply_advanced_formatting(words, false, false);\n\n        // Should have basic punctuation but no capitalization or symbols\n        assert!(result.ends_with('.') || result.ends_with('!') || result.ends_with('?'));\n\n        // Should not start with capital (unless word itself was capitalized)\n        assert!(\n            !result.chars().next().unwrap().is_uppercase(),\n            \"Should not capitalize without flag\"\n        );\n\n        // Should not have symbols\n        let symbol_chars = \"@#$%^&*()[]{}|\\\\~`+-=<>\";\n        let main_content = &result[..result.len() - 1]; // Remove final punctuation\n        let has_symbols_in_main = main_content.chars().any(|c| symbol_chars.contains(c));\n        assert!(!has_symbols_in_main, \"Should not have symbols without flag\");\n    }\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":8}},{"line":13,"address":[],"length":0,"stats":{"Line":8}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":8}},{"line":18,"address":[],"length":0,"stats":{"Line":8}},{"line":21,"address":[],"length":0,"stats":{"Line":8}},{"line":22,"address":[],"length":0,"stats":{"Line":8}},{"line":23,"address":[],"length":0,"stats":{"Line":8}},{"line":25,"address":[],"length":0,"stats":{"Line":21}},{"line":29,"address":[],"length":0,"stats":{"Line":28}},{"line":30,"address":[],"length":0,"stats":{"Line":6}},{"line":36,"address":[],"length":0,"stats":{"Line":9}},{"line":37,"address":[],"length":0,"stats":{"Line":2}},{"line":38,"address":[],"length":0,"stats":{"Line":2}},{"line":41,"address":[],"length":0,"stats":{"Line":1}},{"line":42,"address":[],"length":0,"stats":{"Line":1}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":1}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":1}},{"line":51,"address":[],"length":0,"stats":{"Line":2}},{"line":52,"address":[],"length":0,"stats":{"Line":1}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":13}},{"line":77,"address":[],"length":0,"stats":{"Line":5}},{"line":78,"address":[],"length":0,"stats":{"Line":5}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":5}},{"line":85,"address":[],"length":0,"stats":{"Line":9}},{"line":86,"address":[],"length":0,"stats":{"Line":1}},{"line":95,"address":[],"length":0,"stats":{"Line":8}},{"line":96,"address":[],"length":0,"stats":{"Line":6}},{"line":97,"address":[],"length":0,"stats":{"Line":2}},{"line":98,"address":[],"length":0,"stats":{"Line":4}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":4}},{"line":106,"address":[],"length":0,"stats":{"Line":4}},{"line":107,"address":[],"length":0,"stats":{"Line":8}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":11}},{"line":127,"address":[],"length":0,"stats":{"Line":11}},{"line":128,"address":[],"length":0,"stats":{"Line":30}},{"line":129,"address":[],"length":0,"stats":{"Line":9}},{"line":131,"address":[],"length":0,"stats":{"Line":11}}],"covered":37,"coverable":54},{"path":["/","Users","martintrojer","hacking","thokr","src","language","mod.rs"],"content":"pub mod core;\npub mod difficulty;\npub mod formatter;\npub mod formatting;\npub mod selection;\npub mod selector;\npub mod sentences;\n\n// Re-export the main types for convenience\npub use core::Language;\npub use difficulty::CharacterDifficulty;\npub use formatter::{\n    BasicFormatter, CapitalizationFormatter, CompositeFormatter, SymbolFormatter, TextFormatter,\n};\npub use selector::{IntelligentSelector, RandomSelector, SubstitutionSelector, WordSelector};\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_integrated_functionality() {\n        let lang = Language::new(\"english\".to_string());\n\n        // Test that all functionality works together\n        let words = lang.get_random(5);\n        assert_eq!(words.len(), 5);\n\n        let formatted = lang.apply_advanced_formatting(words, true, false);\n        assert!(!formatted.is_empty());\n        assert!(formatted.chars().next().unwrap().is_uppercase());\n    }\n\n    #[test]\n    fn test_substitution_with_formatting() {\n        let lang = Language::new(\"english\".to_string());\n\n        let mut char_stats = HashMap::new();\n        char_stats.insert(\n            'x',\n            CharacterDifficulty {\n                miss_rate: 20.0,\n                avg_time_ms: 300.0,\n                total_attempts: 10,\n                uppercase_miss_rate: 25.0,\n                uppercase_avg_time: 400.0,\n                uppercase_attempts: 3,\n                uppercase_penalty: 0.5,\n            },\n        );\n\n        let substituted_words = lang.get_substituted(3, &char_stats);\n        let formatted = lang.apply_advanced_formatting(substituted_words, true, true);\n\n        assert!(!formatted.is_empty());\n        // Should have capitalization (first alphabetic character should be uppercase)\n        let first_alpha_char = formatted.chars().find(|c| c.is_alphabetic());\n        if let Some(first_char) = first_alpha_char {\n            assert!(first_char.is_uppercase());\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","martintrojer","hacking","thokr","src","language","selection.rs"],"content":"use super::{core::Language, difficulty::CharacterDifficulty};\nuse rand::seq::SliceRandom;\nuse rand::Rng;\nuse std::collections::HashMap;\n\nimpl Language {\n    /// Get random words from the language\n    pub fn get_random(&self, num: usize) -> Vec<String> {\n        let mut rng = &mut rand::thread_rng();\n        self.words.choose_multiple(&mut rng, num).cloned().collect()\n    }\n\n    /// Get words with character substitution: replace some characters with ones that need most practice\n    pub fn get_substituted(\n        &self,\n        num: usize,\n        char_stats: &HashMap<char, CharacterDifficulty>,\n    ) -> Vec<String> {\n        if char_stats.is_empty() {\n            // Fall back to random selection if no statistics available\n            return self.get_random(num);\n        }\n\n        // Get regular words first\n        let base_words = self.get_random(num);\n\n        // Find the most difficult characters to practice\n        let weak_chars = self.get_weakest_characters(char_stats, 10);\n\n        // For each word, substitute some characters with weak ones\n        base_words\n            .into_iter()\n            .map(|word| self.substitute_characters_in_word(&word, &weak_chars))\n            .collect()\n    }\n\n    /// Get words intelligently selected based on character statistics\n    /// Words containing characters that need more practice are prioritized\n    pub fn get_intelligent(\n        &self,\n        num: usize,\n        char_stats: &HashMap<char, CharacterDifficulty>,\n    ) -> Vec<String> {\n        if char_stats.is_empty() {\n            // Fall back to random selection if no statistics available\n            return self.get_random(num);\n        }\n\n        // Score each word based on the difficulty of characters it contains\n        let mut word_scores: Vec<(String, f64)> = self\n            .words\n            .iter()\n            .map(|word| {\n                let score = self.calculate_word_difficulty_score(word, char_stats);\n                (word.clone(), score)\n            })\n            .collect();\n\n        // Sort by score (highest difficulty first for more practice)\n        word_scores.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap_or(std::cmp::Ordering::Equal));\n\n        // Select from top 30% of difficult words to avoid repetition while still targeting weak areas\n        let selection_pool_size = (word_scores.len() as f64 * 0.3)\n            .max(num as f64)\n            .min(word_scores.len() as f64) as usize;\n        let selection_pool = &word_scores[0..selection_pool_size];\n\n        // Randomly select from the high-difficulty pool\n        let mut rng = &mut rand::thread_rng();\n        selection_pool\n            .choose_multiple(&mut rng, num)\n            .map(|(word, _score)| word.clone())\n            .collect()\n    }\n\n    /// Calculate difficulty score for a word based on character statistics\n    fn calculate_word_difficulty_score(\n        &self,\n        word: &str,\n        char_stats: &HashMap<char, CharacterDifficulty>,\n    ) -> f64 {\n        let chars: Vec<char> = word.chars().collect();\n        if chars.is_empty() {\n            return 0.0;\n        }\n\n        let mut total_score = 0.0;\n        let mut char_count = 0;\n\n        for ch in chars {\n            let base_char = ch.to_lowercase().next().unwrap_or(ch);\n            let is_uppercase = ch != base_char;\n\n            if let Some(difficulty) = char_stats.get(&base_char) {\n                // Base difficulty calculation\n                let miss_penalty = difficulty.miss_rate * 2.0; // Miss rate has higher weight\n                let timing_penalty = if difficulty.avg_time_ms > 200.0 {\n                    (difficulty.avg_time_ms - 200.0) / 100.0 // Normalize timing penalty\n                } else {\n                    0.0\n                };\n\n                let mut char_score = miss_penalty + timing_penalty;\n\n                // Apply uppercase penalty if applicable\n                if is_uppercase && ch.is_alphabetic() {\n                    let uppercase_multiplier = 1.0 + difficulty.uppercase_penalty;\n                    char_score *= uppercase_multiplier;\n\n                    // Additional penalty based on uppercase-specific performance\n                    if difficulty.uppercase_attempts > 0 {\n                        let uppercase_miss_penalty = difficulty.uppercase_miss_rate * 1.5;\n                        let uppercase_timing_penalty = if difficulty.uppercase_avg_time > 200.0 {\n                            (difficulty.uppercase_avg_time - 200.0) / 100.0\n                        } else {\n                            0.0\n                        };\n                        char_score += (uppercase_miss_penalty + uppercase_timing_penalty) * 0.5;\n                    }\n                }\n\n                total_score += char_score;\n                char_count += 1;\n            } else if ch.is_alphabetic() {\n                // Unknown alphabetic characters get higher priority if uppercase\n                let base_score = 5.0;\n                total_score += if is_uppercase {\n                    base_score * 1.5\n                } else {\n                    base_score\n                };\n                char_count += 1;\n            } else {\n                // Punctuation gets medium difficulty score\n                total_score += 3.0;\n                char_count += 1;\n            }\n        }\n\n        if char_count == 0 {\n            0.0\n        } else {\n            total_score / char_count as f64\n        }\n    }\n\n    /// Get the weakest characters (those that need most practice) from character statistics\n    fn get_weakest_characters(\n        &self,\n        char_stats: &HashMap<char, CharacterDifficulty>,\n        count: usize,\n    ) -> Vec<char> {\n        let mut char_difficulties: Vec<(char, f64)> = char_stats\n            .iter()\n            .map(|(ch, difficulty)| {\n                // Calculate combined difficulty score (higher = more practice needed)\n                let miss_penalty = difficulty.miss_rate * 2.0;\n                let timing_penalty = if difficulty.avg_time_ms > 200.0 {\n                    (difficulty.avg_time_ms - 200.0) / 100.0\n                } else {\n                    0.0\n                };\n                let combined_difficulty = miss_penalty + timing_penalty;\n                (*ch, combined_difficulty)\n            })\n            .collect();\n\n        // Sort by difficulty (highest first)\n        char_difficulties\n            .sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap_or(std::cmp::Ordering::Equal));\n\n        // Return the weakest characters, limited by count\n        char_difficulties\n            .into_iter()\n            .take(count)\n            .map(|(ch, _)| ch)\n            .collect()\n    }\n\n    /// Substitute some characters in a word with weaker characters for practice\n    fn substitute_characters_in_word(&self, word: &str, weak_chars: &[char]) -> String {\n        if weak_chars.is_empty() || word.is_empty() {\n            return word.to_string();\n        }\n\n        let rng = &mut rand::thread_rng();\n        let chars: Vec<char> = word.chars().collect();\n        let mut result: Vec<char> = Vec::with_capacity(chars.len());\n\n        for ch in chars {\n            // Only substitute alphabetic characters, preserve punctuation/spaces\n            if ch.is_alphabetic() && rng.gen_bool(0.3) {\n                // 30% chance to substitute each character\n                if let Some(&weak_char) = weak_chars.choose(rng) {\n                    // Preserve case: if original was uppercase, make weak char uppercase too\n                    if ch.is_uppercase() {\n                        result.push(weak_char.to_uppercase().next().unwrap_or(weak_char));\n                    } else {\n                        result.push(weak_char);\n                    }\n                } else {\n                    result.push(ch);\n                }\n            } else {\n                result.push(ch);\n            }\n        }\n\n        result.into_iter().collect()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn create_test_language() -> Language {\n        Language {\n            name: \"test\".to_string(),\n            size: 4,\n            words: vec![\n                \"easy\".to_string(), // Contains 'e' (easy)\n                \"hard\".to_string(), // Contains 'h' (hard)\n                \"test\".to_string(), // Contains 't' (medium)\n                \"zap\".to_string(),  // Contains 'z' (very hard)\n            ],\n        }\n    }\n\n    fn create_test_char_stats() -> HashMap<char, CharacterDifficulty> {\n        let mut char_stats = HashMap::new();\n        char_stats.insert(\n            'e',\n            CharacterDifficulty {\n                miss_rate: 2.0,\n                avg_time_ms: 120.0,\n                total_attempts: 50,\n                uppercase_miss_rate: 5.0,\n                uppercase_avg_time: 140.0,\n                uppercase_attempts: 10,\n                uppercase_penalty: 0.2,\n            },\n        );\n        char_stats.insert(\n            'h',\n            CharacterDifficulty {\n                miss_rate: 15.0,\n                avg_time_ms: 250.0,\n                total_attempts: 30,\n                uppercase_miss_rate: 25.0,\n                uppercase_avg_time: 350.0,\n                uppercase_attempts: 8,\n                uppercase_penalty: 0.6,\n            },\n        );\n        char_stats.insert(\n            't',\n            CharacterDifficulty {\n                miss_rate: 8.0,\n                avg_time_ms: 180.0,\n                total_attempts: 40,\n                uppercase_miss_rate: 12.0,\n                uppercase_avg_time: 220.0,\n                uppercase_attempts: 15,\n                uppercase_penalty: 0.3,\n            },\n        );\n        char_stats.insert(\n            'z',\n            CharacterDifficulty {\n                miss_rate: 25.0,\n                avg_time_ms: 400.0,\n                total_attempts: 10,\n                uppercase_miss_rate: 40.0,\n                uppercase_avg_time: 600.0,\n                uppercase_attempts: 3,\n                uppercase_penalty: 0.8,\n            },\n        );\n        char_stats\n    }\n\n    #[test]\n    fn test_get_random_words() {\n        let lang = Language::new(\"english\".to_string());\n\n        let words = lang.get_random(5);\n        assert_eq!(words.len(), 5);\n\n        for word in &words {\n            assert!(lang.words.contains(word));\n        }\n    }\n\n    #[test]\n    fn test_get_random_single_word() {\n        let lang = Language::new(\"english\".to_string());\n\n        let words = lang.get_random(1);\n        assert_eq!(words.len(), 1);\n        assert!(lang.words.contains(&words[0]));\n    }\n\n    #[test]\n    fn test_get_random_zero_words() {\n        let lang = Language::new(\"english\".to_string());\n\n        let words = lang.get_random(0);\n        assert_eq!(words.len(), 0);\n    }\n\n    #[test]\n    fn test_intelligent_selection_prioritizes_difficult_characters() {\n        let lang = create_test_language();\n        let char_stats = create_test_char_stats();\n\n        // Test multiple selections to check statistical preference\n        let mut hard_count = 0;\n        let mut zap_count = 0;\n        let trials = 100;\n\n        for _ in 0..trials {\n            let words = lang.get_intelligent(2, &char_stats);\n            if words.contains(&\"hard\".to_string()) {\n                hard_count += 1;\n            }\n            if words.contains(&\"zap\".to_string()) {\n                zap_count += 1;\n            }\n        }\n\n        // \"zap\" and \"hard\" should be selected more often than \"easy\"\n        // due to higher difficulty scores\n        assert!(\n            zap_count > trials / 4,\n            \"zap should be selected frequently (got {} out of {})\",\n            zap_count,\n            trials\n        );\n        assert!(\n            hard_count > trials / 4,\n            \"hard should be selected frequently (got {} out of {})\",\n            hard_count,\n            trials\n        );\n    }\n\n    #[test]\n    fn test_get_substituted_returns_correct_count() {\n        let lang = Language::new(\"english\".to_string());\n\n        let mut char_stats = HashMap::new();\n        char_stats.insert(\n            'x',\n            CharacterDifficulty {\n                miss_rate: 20.0,\n                avg_time_ms: 300.0,\n                total_attempts: 10,\n                uppercase_miss_rate: 25.0,\n                uppercase_avg_time: 400.0,\n                uppercase_attempts: 3,\n                uppercase_penalty: 0.5,\n            },\n        );\n\n        for count in [1, 5, 10] {\n            let words = lang.get_substituted(count, &char_stats);\n            assert_eq!(words.len(), count, \"Should return exactly {} words\", count);\n        }\n    }\n}\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":8}},{"line":9,"address":[],"length":0,"stats":{"Line":8}},{"line":10,"address":[],"length":0,"stats":{"Line":8}},{"line":14,"address":[],"length":0,"stats":{"Line":4}},{"line":19,"address":[],"length":0,"stats":{"Line":4}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":4}},{"line":28,"address":[],"length":0,"stats":{"Line":4}},{"line":31,"address":[],"length":0,"stats":{"Line":4}},{"line":33,"address":[],"length":0,"stats":{"Line":23}},{"line":39,"address":[],"length":0,"stats":{"Line":100}},{"line":44,"address":[],"length":0,"stats":{"Line":100}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":100}},{"line":51,"address":[],"length":0,"stats":{"Line":100}},{"line":53,"address":[],"length":0,"stats":{"Line":500}},{"line":54,"address":[],"length":0,"stats":{"Line":400}},{"line":55,"address":[],"length":0,"stats":{"Line":400}},{"line":60,"address":[],"length":0,"stats":{"Line":600}},{"line":72,"address":[],"length":0,"stats":{"Line":200}},{"line":77,"address":[],"length":0,"stats":{"Line":400}},{"line":82,"address":[],"length":0,"stats":{"Line":400}},{"line":83,"address":[],"length":0,"stats":{"Line":400}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":400}},{"line":88,"address":[],"length":0,"stats":{"Line":400}},{"line":90,"address":[],"length":0,"stats":{"Line":3400}},{"line":94,"address":[],"length":0,"stats":{"Line":600}},{"line":98,"address":[],"length":0,"stats":{"Line":200}},{"line":100,"address":[],"length":0,"stats":{"Line":400}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":900}},{"line":126,"address":[],"length":0,"stats":{"Line":900}},{"line":127,"address":[],"length":0,"stats":{"Line":900}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":900}},{"line":132,"address":[],"length":0,"stats":{"Line":900}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":400}},{"line":148,"address":[],"length":0,"stats":{"Line":4}},{"line":153,"address":[],"length":0,"stats":{"Line":4}},{"line":155,"address":[],"length":0,"stats":{"Line":8}},{"line":157,"address":[],"length":0,"stats":{"Line":4}},{"line":158,"address":[],"length":0,"stats":{"Line":8}},{"line":159,"address":[],"length":0,"stats":{"Line":4}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":4}},{"line":164,"address":[],"length":0,"stats":{"Line":4}},{"line":169,"address":[],"length":0,"stats":{"Line":4}},{"line":170,"address":[],"length":0,"stats":{"Line":8}},{"line":173,"address":[],"length":0,"stats":{"Line":4}},{"line":175,"address":[],"length":0,"stats":{"Line":4}},{"line":176,"address":[],"length":0,"stats":{"Line":12}},{"line":181,"address":[],"length":0,"stats":{"Line":19}},{"line":182,"address":[],"length":0,"stats":{"Line":38}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":19}},{"line":187,"address":[],"length":0,"stats":{"Line":19}},{"line":188,"address":[],"length":0,"stats":{"Line":19}},{"line":190,"address":[],"length":0,"stats":{"Line":169}},{"line":192,"address":[],"length":0,"stats":{"Line":75}},{"line":194,"address":[],"length":0,"stats":{"Line":58}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":29}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":46}}],"covered":56,"coverable":77},{"path":["/","Users","martintrojer","hacking","thokr","src","language","selector.rs"],"content":"use super::{core::Language, difficulty::CharacterDifficulty};\nuse rand::seq::SliceRandom;\nuse rand::Rng;\nuse std::collections::HashMap;\n\n/// Trait for different word selection strategies\npub trait WordSelector {\n    /// Select words from the language based on the strategy\n    fn select_words(\n        &self,\n        language: &Language,\n        count: usize,\n        char_stats: &HashMap<char, CharacterDifficulty>,\n    ) -> Vec<String>;\n}\n\n/// Random word selection (legacy behavior)\npub struct RandomSelector;\n\nimpl WordSelector for RandomSelector {\n    fn select_words(\n        &self,\n        language: &Language,\n        count: usize,\n        _char_stats: &HashMap<char, CharacterDifficulty>,\n    ) -> Vec<String> {\n        let mut rng = &mut rand::thread_rng();\n        language\n            .words\n            .choose_multiple(&mut rng, count)\n            .cloned()\n            .collect()\n    }\n}\n\n/// Intelligent word selection based on character difficulty\npub struct IntelligentSelector;\n\nimpl WordSelector for IntelligentSelector {\n    fn select_words(\n        &self,\n        language: &Language,\n        count: usize,\n        char_stats: &HashMap<char, CharacterDifficulty>,\n    ) -> Vec<String> {\n        if char_stats.is_empty() {\n            // Fall back to random selection if no statistics available\n            return RandomSelector.select_words(language, count, char_stats);\n        }\n\n        // Score each word based on the difficulty of characters it contains\n        let mut word_scores: Vec<(String, f64)> = language\n            .words\n            .iter()\n            .map(|word| {\n                let score = calculate_word_difficulty_score(word, char_stats);\n                (word.clone(), score)\n            })\n            .collect();\n\n        // Sort by score (highest difficulty first for more practice)\n        word_scores.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap_or(std::cmp::Ordering::Equal));\n\n        // Select from top 30% of difficult words to avoid repetition while still targeting weak areas\n        let selection_pool_size = (word_scores.len() as f64 * 0.3)\n            .max(count as f64)\n            .min(word_scores.len() as f64) as usize;\n        let selection_pool = &word_scores[0..selection_pool_size];\n\n        // Randomly select from the high-difficulty pool\n        let mut rng = &mut rand::thread_rng();\n        selection_pool\n            .choose_multiple(&mut rng, count)\n            .map(|(word, _score)| word.clone())\n            .collect()\n    }\n}\n\n/// Character substitution selector\npub struct SubstitutionSelector;\n\nimpl WordSelector for SubstitutionSelector {\n    fn select_words(\n        &self,\n        language: &Language,\n        count: usize,\n        char_stats: &HashMap<char, CharacterDifficulty>,\n    ) -> Vec<String> {\n        if char_stats.is_empty() {\n            // Fall back to random selection if no statistics available\n            return RandomSelector.select_words(language, count, char_stats);\n        }\n\n        // Get regular words first\n        let base_words = RandomSelector.select_words(language, count, char_stats);\n\n        // Find the most difficult characters to practice\n        let weak_chars = get_weakest_characters(char_stats, 10);\n\n        // For each word, substitute some characters with weak ones\n        base_words\n            .into_iter()\n            .map(|word| substitute_characters_in_word(&word, &weak_chars))\n            .collect()\n    }\n}\n\n/// Calculate difficulty score for a word based on character statistics\nfn calculate_word_difficulty_score(\n    word: &str,\n    char_stats: &HashMap<char, CharacterDifficulty>,\n) -> f64 {\n    let chars: Vec<char> = word.chars().collect();\n    if chars.is_empty() {\n        return 0.0;\n    }\n\n    let mut total_score = 0.0;\n    let mut char_count = 0;\n\n    for ch in chars {\n        let base_char = ch.to_lowercase().next().unwrap_or(ch);\n        let is_uppercase = ch != base_char;\n\n        if let Some(difficulty) = char_stats.get(&base_char) {\n            // Base difficulty calculation\n            let miss_penalty = difficulty.miss_rate * 2.0; // Miss rate has higher weight\n            let timing_penalty = if difficulty.avg_time_ms > 200.0 {\n                (difficulty.avg_time_ms - 200.0) / 100.0 // Normalize timing penalty\n            } else {\n                0.0\n            };\n\n            let mut char_score = miss_penalty + timing_penalty;\n\n            // Apply uppercase penalty if applicable\n            if is_uppercase && ch.is_alphabetic() {\n                let uppercase_multiplier = 1.0 + difficulty.uppercase_penalty;\n                char_score *= uppercase_multiplier;\n\n                // Additional penalty based on uppercase-specific performance\n                if difficulty.uppercase_attempts > 0 {\n                    let uppercase_miss_penalty = difficulty.uppercase_miss_rate * 1.5;\n                    let uppercase_timing_penalty = if difficulty.uppercase_avg_time > 200.0 {\n                        (difficulty.uppercase_avg_time - 200.0) / 100.0\n                    } else {\n                        0.0\n                    };\n                    char_score += (uppercase_miss_penalty + uppercase_timing_penalty) * 0.5;\n                }\n            }\n\n            total_score += char_score;\n            char_count += 1;\n        } else if ch.is_alphabetic() {\n            // Unknown alphabetic characters get higher priority if uppercase\n            let base_score = 5.0;\n            total_score += if is_uppercase {\n                base_score * 1.5\n            } else {\n                base_score\n            };\n            char_count += 1;\n        } else {\n            // Punctuation gets medium difficulty score\n            total_score += 3.0;\n            char_count += 1;\n        }\n    }\n\n    if char_count == 0 {\n        0.0\n    } else {\n        total_score / char_count as f64\n    }\n}\n\n/// Get the weakest characters (those that need most practice) from character statistics\nfn get_weakest_characters(\n    char_stats: &HashMap<char, CharacterDifficulty>,\n    count: usize,\n) -> Vec<char> {\n    let mut char_difficulties: Vec<(char, f64)> = char_stats\n        .iter()\n        .map(|(ch, difficulty)| {\n            // Calculate combined difficulty score (higher = more practice needed)\n            let miss_penalty = difficulty.miss_rate * 2.0;\n            let timing_penalty = if difficulty.avg_time_ms > 200.0 {\n                (difficulty.avg_time_ms - 200.0) / 100.0\n            } else {\n                0.0\n            };\n            let combined_difficulty = miss_penalty + timing_penalty;\n            (*ch, combined_difficulty)\n        })\n        .collect();\n\n    // Sort by difficulty (highest first)\n    char_difficulties.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap_or(std::cmp::Ordering::Equal));\n\n    // Return the weakest characters, limited by count\n    char_difficulties\n        .into_iter()\n        .take(count)\n        .map(|(ch, _)| ch)\n        .collect()\n}\n\n/// Substitute some characters in a word with weaker characters for practice\nfn substitute_characters_in_word(word: &str, weak_chars: &[char]) -> String {\n    if weak_chars.is_empty() || word.is_empty() {\n        return word.to_string();\n    }\n\n    let rng = &mut rand::thread_rng();\n    let chars: Vec<char> = word.chars().collect();\n    let mut result: Vec<char> = Vec::with_capacity(chars.len());\n\n    for ch in chars {\n        // Only substitute alphabetic characters, preserve punctuation/spaces\n        if ch.is_alphabetic() && rng.gen_bool(0.3) {\n            // 30% chance to substitute each character\n            if let Some(&weak_char) = weak_chars.choose(rng) {\n                // Preserve case: if original was uppercase, make weak char uppercase too\n                if ch.is_uppercase() {\n                    result.push(weak_char.to_uppercase().next().unwrap_or(weak_char));\n                } else {\n                    result.push(weak_char);\n                }\n            } else {\n                result.push(ch);\n            }\n        } else {\n            result.push(ch);\n        }\n    }\n\n    result.into_iter().collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn create_test_language() -> Language {\n        Language {\n            name: \"test\".to_string(),\n            size: 4,\n            words: vec![\n                \"easy\".to_string(),\n                \"hard\".to_string(),\n                \"test\".to_string(),\n                \"zap\".to_string(),\n            ],\n        }\n    }\n\n    fn create_test_char_stats() -> HashMap<char, CharacterDifficulty> {\n        let mut char_stats = HashMap::new();\n        char_stats.insert(\n            'z',\n            CharacterDifficulty {\n                miss_rate: 25.0,\n                avg_time_ms: 400.0,\n                total_attempts: 10,\n                uppercase_miss_rate: 40.0,\n                uppercase_avg_time: 600.0,\n                uppercase_attempts: 3,\n                uppercase_penalty: 0.8,\n            },\n        );\n        char_stats\n    }\n\n    #[test]\n    fn test_random_selector() {\n        let selector = RandomSelector;\n        let language = create_test_language();\n        let char_stats = HashMap::new();\n\n        let words = selector.select_words(&language, 2, &char_stats);\n        assert_eq!(words.len(), 2);\n\n        for word in &words {\n            assert!(language.words.contains(word));\n        }\n    }\n\n    #[test]\n    fn test_intelligent_selector() {\n        let selector = IntelligentSelector;\n        let language = create_test_language();\n        let char_stats = create_test_char_stats();\n\n        let words = selector.select_words(&language, 2, &char_stats);\n        assert_eq!(words.len(), 2);\n\n        for word in &words {\n            assert!(language.words.contains(word));\n        }\n    }\n\n    #[test]\n    fn test_substitution_selector() {\n        let selector = SubstitutionSelector;\n        let language = create_test_language();\n        let char_stats = create_test_char_stats();\n\n        let words = selector.select_words(&language, 2, &char_stats);\n        assert_eq!(words.len(), 2);\n\n        // Words should be same length as originals but potentially modified\n        for word in &words {\n            assert!(!word.is_empty());\n        }\n    }\n\n    #[test]\n    fn test_selector_fallback_to_random() {\n        let selectors: Vec<Box<dyn WordSelector>> = vec![\n            Box::new(IntelligentSelector),\n            Box::new(SubstitutionSelector),\n        ];\n\n        let language = create_test_language();\n        let empty_stats = HashMap::new();\n\n        for selector in selectors {\n            let words = selector.select_words(&language, 2, &empty_stats);\n            assert_eq!(words.len(), 2);\n\n            for word in &words {\n                assert!(language.words.contains(word));\n            }\n        }\n    }\n\n    #[test]\n    fn test_calculate_word_difficulty_score() {\n        let char_stats = create_test_char_stats();\n\n        let score1 = calculate_word_difficulty_score(\"zap\", &char_stats);\n        let score2 = calculate_word_difficulty_score(\"easy\", &char_stats);\n\n        // Word with difficult character should score higher\n        assert!(score1 > score2);\n    }\n\n    #[test]\n    fn test_calculate_word_difficulty_score_edge_cases() {\n        let char_stats = create_test_char_stats();\n\n        // Empty word\n        let empty_score = calculate_word_difficulty_score(\"\", &char_stats);\n        assert_eq!(empty_score, 0.0);\n\n        // Word with unknown characters\n        let unknown_score = calculate_word_difficulty_score(\"xyz\", &HashMap::new());\n        assert!(unknown_score > 0.0);\n\n        // Word with mixed known and unknown characters\n        let mixed_score = calculate_word_difficulty_score(\"zxy\", &char_stats);\n        assert!(mixed_score > 0.0);\n    }\n\n    #[test]\n    fn test_get_weakest_characters() {\n        let char_stats = create_test_char_stats();\n\n        let weak_chars = get_weakest_characters(&char_stats, 1);\n        assert_eq!(weak_chars.len(), 1);\n        assert_eq!(weak_chars[0], 'z'); // 'z' should be the weakest based on our test data\n\n        // Test with more characters than available\n        let all_weak_chars = get_weakest_characters(&char_stats, 10);\n        assert_eq!(all_weak_chars.len(), 1); // Only one character in test data\n    }\n\n    #[test]\n    fn test_substitute_characters_in_word() {\n        let weak_chars = vec!['x', 'y', 'z'];\n\n        // Test with empty word\n        let empty_result = substitute_characters_in_word(\"\", &weak_chars);\n        assert_eq!(empty_result, \"\");\n\n        // Test with empty weak chars\n        let no_substitution = substitute_characters_in_word(\"hello\", &[]);\n        assert_eq!(no_substitution, \"hello\");\n\n        // Test with actual substitution - should preserve word length\n        let substituted = substitute_characters_in_word(\"hello\", &weak_chars);\n        assert_eq!(substituted.len(), 5);\n\n        // Test case preservation\n        let uppercase_result = substitute_characters_in_word(\"HELLO\", &weak_chars);\n        assert_eq!(uppercase_result.len(), 5);\n        // At least the first character should remain uppercase if substituted\n        if !uppercase_result.starts_with('H') {\n            assert!(uppercase_result.chars().next().unwrap().is_uppercase());\n        }\n    }\n\n    #[test]\n    fn test_word_selectors_with_different_counts() {\n        let language = create_test_language();\n        let char_stats = create_test_char_stats();\n\n        let selectors: Vec<Box<dyn WordSelector>> = vec![\n            Box::new(RandomSelector),\n            Box::new(IntelligentSelector),\n            Box::new(SubstitutionSelector),\n        ];\n\n        for selector in selectors {\n            // Test with count 0\n            let zero_words = selector.select_words(&language, 0, &char_stats);\n            assert_eq!(zero_words.len(), 0);\n\n            // Test with count 1\n            let one_word = selector.select_words(&language, 1, &char_stats);\n            assert_eq!(one_word.len(), 1);\n\n            // Test with count larger than available words\n            let many_words = selector.select_words(&language, 100, &char_stats);\n            assert!(many_words.len() <= language.words.len());\n        }\n    }\n\n    #[test]\n    fn test_calculate_word_difficulty_score_with_uppercase() {\n        let mut char_stats = HashMap::new();\n        char_stats.insert(\n            'a',\n            CharacterDifficulty {\n                miss_rate: 10.0,\n                avg_time_ms: 200.0,\n                total_attempts: 20,\n                uppercase_miss_rate: 25.0,\n                uppercase_avg_time: 350.0,\n                uppercase_attempts: 5,\n                uppercase_penalty: 0.8,\n            },\n        );\n\n        let lowercase_score = calculate_word_difficulty_score(\"aaa\", &char_stats);\n        let uppercase_score = calculate_word_difficulty_score(\"AAA\", &char_stats);\n\n        // Uppercase should score higher due to penalty\n        assert!(uppercase_score > lowercase_score);\n    }\n\n    #[test]\n    fn test_intelligent_selector_with_limited_words() {\n        let small_language = Language {\n            name: \"small\".to_string(),\n            size: 2,\n            words: vec![\"a\".to_string(), \"z\".to_string()],\n        };\n\n        let char_stats = create_test_char_stats();\n        let selector = IntelligentSelector;\n\n        let words = selector.select_words(&small_language, 2, &char_stats);\n        assert_eq!(words.len(), 2);\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":15}},{"line":27,"address":[],"length":0,"stats":{"Line":15}},{"line":28,"address":[],"length":0,"stats":{"Line":15}},{"line":29,"address":[],"length":0,"stats":{"Line":15}},{"line":30,"address":[],"length":0,"stats":{"Line":15}},{"line":40,"address":[],"length":0,"stats":{"Line":16}},{"line":46,"address":[],"length":0,"stats":{"Line":16}},{"line":48,"address":[],"length":0,"stats":{"Line":1}},{"line":52,"address":[],"length":0,"stats":{"Line":15}},{"line":53,"address":[],"length":0,"stats":{"Line":15}},{"line":55,"address":[],"length":0,"stats":{"Line":2033}},{"line":56,"address":[],"length":0,"stats":{"Line":2018}},{"line":57,"address":[],"length":0,"stats":{"Line":2018}},{"line":62,"address":[],"length":0,"stats":{"Line":16430}},{"line":74,"address":[],"length":0,"stats":{"Line":69}},{"line":83,"address":[],"length":0,"stats":{"Line":9}},{"line":89,"address":[],"length":0,"stats":{"Line":9}},{"line":91,"address":[],"length":0,"stats":{"Line":1}},{"line":95,"address":[],"length":0,"stats":{"Line":8}},{"line":98,"address":[],"length":0,"stats":{"Line":8}},{"line":101,"address":[],"length":0,"stats":{"Line":8}},{"line":103,"address":[],"length":0,"stats":{"Line":35}},{"line":109,"address":[],"length":0,"stats":{"Line":2025}},{"line":113,"address":[],"length":0,"stats":{"Line":2025}},{"line":114,"address":[],"length":0,"stats":{"Line":2025}},{"line":115,"address":[],"length":0,"stats":{"Line":1}},{"line":118,"address":[],"length":0,"stats":{"Line":2024}},{"line":119,"address":[],"length":0,"stats":{"Line":2024}},{"line":121,"address":[],"length":0,"stats":{"Line":19126}},{"line":125,"address":[],"length":0,"stats":{"Line":7373}},{"line":129,"address":[],"length":0,"stats":{"Line":7}},{"line":131,"address":[],"length":0,"stats":{"Line":7366}},{"line":137,"address":[],"length":0,"stats":{"Line":13}},{"line":138,"address":[],"length":0,"stats":{"Line":13}},{"line":139,"address":[],"length":0,"stats":{"Line":13}},{"line":142,"address":[],"length":0,"stats":{"Line":13}},{"line":143,"address":[],"length":0,"stats":{"Line":13}},{"line":144,"address":[],"length":0,"stats":{"Line":26}},{"line":145,"address":[],"length":0,"stats":{"Line":13}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":13}},{"line":155,"address":[],"length":0,"stats":{"Line":1178}},{"line":157,"address":[],"length":0,"stats":{"Line":1178}},{"line":158,"address":[],"length":0,"stats":{"Line":1178}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":1178}},{"line":163,"address":[],"length":0,"stats":{"Line":1178}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":2024}},{"line":179,"address":[],"length":0,"stats":{"Line":10}},{"line":183,"address":[],"length":0,"stats":{"Line":10}},{"line":185,"address":[],"length":0,"stats":{"Line":92}},{"line":187,"address":[],"length":0,"stats":{"Line":82}},{"line":188,"address":[],"length":0,"stats":{"Line":164}},{"line":189,"address":[],"length":0,"stats":{"Line":6}},{"line":191,"address":[],"length":0,"stats":{"Line":76}},{"line":193,"address":[],"length":0,"stats":{"Line":82}},{"line":194,"address":[],"length":0,"stats":{"Line":82}},{"line":199,"address":[],"length":0,"stats":{"Line":368}},{"line":202,"address":[],"length":0,"stats":{"Line":10}},{"line":204,"address":[],"length":0,"stats":{"Line":10}},{"line":205,"address":[],"length":0,"stats":{"Line":66}},{"line":210,"address":[],"length":0,"stats":{"Line":31}},{"line":211,"address":[],"length":0,"stats":{"Line":61}},{"line":212,"address":[],"length":0,"stats":{"Line":2}},{"line":215,"address":[],"length":0,"stats":{"Line":29}},{"line":216,"address":[],"length":0,"stats":{"Line":29}},{"line":217,"address":[],"length":0,"stats":{"Line":29}},{"line":219,"address":[],"length":0,"stats":{"Line":269}},{"line":221,"address":[],"length":0,"stats":{"Line":120}},{"line":223,"address":[],"length":0,"stats":{"Line":72}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":36}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":84}}],"covered":70,"coverable":78},{"path":["/","Users","martintrojer","hacking","thokr","src","language","sentences.rs"],"content":"use super::core::Language;\nuse cgisf_lib::cgisf;\nuse rand::Rng;\n\nimpl Language {\n    pub fn get_random_sentence(&self, num: usize) -> (Vec<String>, usize) {\n        let rng = &mut rand::thread_rng();\n        let mut vec = Vec::new();\n        let mut word_count = 0;\n        for i in 0..num {\n            let mut s = cgisf(\n                rng.gen_range(1..3),\n                rng.gen_range(1..3),\n                rng.gen_range(1..5),\n                rng.gen_bool(0.5),\n                rng.gen_range(1..3),\n                rng.gen_bool(0.5),\n            );\n            word_count += &s.matches(' ').count();\n            // gets the word count of the sentence.\n            if i == num - 1 {\n                s.pop();\n            }\n            vec.push(s);\n        }\n        (vec, word_count)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_get_random_sentence() {\n        let lang = Language::new(\"english\".to_string());\n\n        let (sentences, word_count) = lang.get_random_sentence(2);\n\n        assert_eq!(sentences.len(), 2);\n        assert!(word_count > 0);\n\n        for sentence in &sentences {\n            assert!(!sentence.is_empty());\n            assert!(sentence.chars().any(|c| c.is_alphabetic()));\n        }\n    }\n\n    #[test]\n    fn test_get_random_sentence_single() {\n        let lang = Language::new(\"english\".to_string());\n\n        let (sentences, word_count) = lang.get_random_sentence(1);\n\n        assert_eq!(sentences.len(), 1);\n        assert!(word_count > 0);\n        assert!(!sentences[0].is_empty());\n    }\n\n    #[test]\n    fn test_get_random_sentence_zero() {\n        let lang = Language::new(\"english\".to_string());\n\n        let (sentences, word_count) = lang.get_random_sentence(0);\n\n        assert_eq!(sentences.len(), 0);\n        assert_eq!(word_count, 0);\n    }\n\n    #[test]\n    fn test_get_random_sentence_word_count_accuracy() {\n        let lang = Language::new(\"english\".to_string());\n\n        let (sentences, word_count) = lang.get_random_sentence(1);\n\n        if !sentences.is_empty() {\n            let actual_word_count = sentences[0].matches(' ').count();\n            assert!(word_count <= actual_word_count + 2);\n        }\n    }\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":7}},{"line":7,"address":[],"length":0,"stats":{"Line":7}},{"line":8,"address":[],"length":0,"stats":{"Line":7}},{"line":9,"address":[],"length":0,"stats":{"Line":7}},{"line":10,"address":[],"length":0,"stats":{"Line":16}},{"line":21,"address":[],"length":0,"stats":{"Line":6}},{"line":22,"address":[],"length":0,"stats":{"Line":6}},{"line":26,"address":[],"length":0,"stats":{"Line":7}}],"covered":8,"coverable":8},{"path":["/","Users","martintrojer","hacking","thokr","src","main.rs"],"content":"pub mod language;\npub mod stats;\npub mod thok;\npub mod ui;\npub mod util;\npub mod word_generator;\n\n// Keep the old lang module name for compatibility\npub use language as lang;\n\nuse crate::{\n    lang::Language,\n    thok::Thok,\n    word_generator::{WordGenConfig, WordGenerator},\n};\nuse clap::{error::ErrorKind, CommandFactory, Parser, ValueEnum};\nuse crossterm::{\n    event::{self, Event, KeyCode, KeyEvent, KeyModifiers},\n    execute,\n    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},\n    tty::IsTty,\n};\nuse ratatui::{\n    backend::{Backend, CrosstermBackend},\n    Frame, Terminal,\n};\nuse std::{\n    error::Error,\n    io::{self, stdin},\n    sync::mpsc,\n    thread,\n    time::Duration,\n};\nuse webbrowser::Browser;\n\nconst TICK_RATE_MS: u64 = 100;\n\n/// sleek typing tui with visualized results and intelligent practice\n#[derive(Parser, Debug, Clone)]\n#[clap(\n    version,\n    about,\n    long_about = \"A sleek typing TUI with intelligent word selection that adapts to your weaknesses, detailed performance analytics, and historical progress tracking.\"\n)]\npub struct Cli {\n    /// number of words to use in test\n    #[clap(short = 'w', long, default_value_t = 15)]\n    number_of_words: usize,\n\n    /// number of sentences to use in test\n    #[clap(short = 'f', long = \"full-sentences\")]\n    number_of_sentences: Option<usize>,\n\n    /// number of seconds to run test\n    #[clap(short = 's', long)]\n    number_of_secs: Option<usize>,\n\n    /// custom prompt to use\n    #[clap(short = 'p', long)]\n    prompt: Option<String>,\n\n    /// language to pull words from\n    #[clap(short = 'l', long, value_enum, default_value_t = SupportedLanguage::English)]\n    supported_language: SupportedLanguage,\n\n    /// use random word selection instead of intelligent character-based selection (default: intelligent selection that targets your weakest characters)\n    #[clap(long)]\n    random_words: bool,\n\n    /// enable capitalization, punctuation, and commas for realistic typing practice\n    #[clap(long)]\n    capitalize: bool,\n\n    /// enable strict mode: stop on errors and require correction before proceeding\n    #[clap(long)]\n    strict: bool,\n\n    /// include symbols and special characters for comprehensive typing practice\n    #[clap(long)]\n    symbols: bool,\n\n    /// enable character substitution mode: create \"almost English\" words by replacing characters with ones that need most practice\n    #[clap(long)]\n    substitute: bool,\n}\n\n#[derive(Debug, Copy, Clone, ValueEnum, strum_macros::Display)]\npub enum SupportedLanguage {\n    English,\n    English1k,\n    English10k,\n}\n\nimpl SupportedLanguage {\n    fn as_lang(&self) -> Language {\n        Language::new(self.to_string().to_lowercase())\n    }\n}\n\nimpl Cli {\n    /// Convert CLI arguments to word generation configuration\n    fn to_word_gen_config(&self, custom_prompt: Option<String>) -> WordGenConfig {\n        WordGenConfig {\n            number_of_words: self.number_of_words,\n            number_of_sentences: self.number_of_sentences,\n            custom_prompt,\n            language: self.supported_language,\n            random_words: self.random_words,\n            substitute: self.substitute,\n            capitalize: self.capitalize,\n            symbols: self.symbols,\n        }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum AppState {\n    Typing,\n    Results,\n    CharacterStats,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum SortBy {\n    Character,\n    AvgTime,\n    MissRate,\n    Attempts,\n}\n\n#[derive(Debug)]\npub struct CharStatsState {\n    pub scroll_offset: usize,\n    pub sort_by: SortBy,\n    pub sort_ascending: bool,\n}\n\nimpl Default for CharStatsState {\n    fn default() -> Self {\n        Self {\n            scroll_offset: 0,\n            sort_by: SortBy::Character,\n            sort_ascending: true,\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct App {\n    pub cli: Option<Cli>,\n    pub thok: Thok,\n    pub state: AppState,\n    pub char_stats_state: CharStatsState,\n}\n\nimpl App {\n    pub fn new(cli: Cli) -> Self {\n        let config = cli.to_word_gen_config(cli.prompt.clone());\n        let generator = WordGenerator::new(config);\n        let (prompt, word_count) = generator.generate_prompt();\n\n        Self {\n            thok: Thok::new(\n                prompt,\n                word_count,\n                cli.number_of_secs.map(|ns| ns as f64),\n                cli.strict,\n            ),\n            cli: Some(cli),\n            state: AppState::Typing,\n            char_stats_state: CharStatsState::default(),\n        }\n    }\n\n    pub fn reset(&mut self, new_prompt: Option<String>) {\n        let cli = self.cli.clone().unwrap();\n        let config = cli.to_word_gen_config(new_prompt);\n        let generator = WordGenerator::new(config);\n        let (prompt, word_count) = generator.generate_prompt();\n\n        self.thok = Thok::new(\n            prompt,\n            word_count,\n            cli.number_of_secs.map(|ns| ns as f64),\n            cli.strict,\n        );\n        self.state = AppState::Typing;\n        self.char_stats_state = CharStatsState::default();\n    }\n}\n\nfn main() -> Result<(), Box<dyn Error>> {\n    let cli = Cli::parse();\n\n    if !stdin().is_tty() {\n        let mut cmd = Cli::command();\n        cmd.error(ErrorKind::Io, \"stdin must be a tty\").exit();\n    }\n\n    enable_raw_mode()?;\n\n    let mut stdout = io::stdout();\n    execute!(stdout, EnterAlternateScreen)?;\n    let backend = CrosstermBackend::new(stdout);\n    let mut terminal = Terminal::new(backend)?;\n\n    let mut app = App::new(cli);\n    start_tui(&mut terminal, &mut app)?;\n\n    disable_raw_mode()?;\n    execute!(terminal.backend_mut(), LeaveAlternateScreen,)?;\n    terminal.show_cursor()?;\n\n    Ok(())\n}\n\n#[derive(Debug)]\nenum ExitType {\n    Restart,\n    New,\n    Quit,\n}\nfn start_tui<B: Backend>(\n    terminal: &mut Terminal<B>,\n    mut app: &mut App,\n) -> Result<(), Box<dyn Error>> {\n    let cli = app.cli.clone();\n\n    let should_tick = cli.unwrap().number_of_secs.unwrap_or(0) > 0;\n\n    let thok_events = get_thok_events(should_tick);\n\n    loop {\n        let mut exit_type: ExitType = ExitType::Quit;\n        terminal.draw(|f| ui(app, f))?;\n\n        loop {\n            let app = &mut app;\n\n            match thok_events.recv()? {\n                ThokEvent::Tick => {\n                    if app.thok.has_started() && !app.thok.has_finished() {\n                        app.thok.on_tick();\n\n                        if app.thok.has_finished() {\n                            app.thok.calc_results();\n                            app.state = AppState::Results;\n                        }\n                        terminal.draw(|f| ui(app, f))?;\n                    }\n                }\n                ThokEvent::Resize => {\n                    terminal.draw(|f| ui(app, f))?;\n                }\n                ThokEvent::Key(key) => {\n                    match key.code {\n                        KeyCode::Esc => {\n                            break;\n                        }\n                        KeyCode::Backspace => {\n                            if app.state == AppState::Typing && !app.thok.has_finished() {\n                                app.thok.backspace();\n                            }\n                        }\n                        KeyCode::Left => {\n                            exit_type = ExitType::Restart;\n                            break;\n                        }\n                        KeyCode::Right => {\n                            exit_type = ExitType::New;\n                            break;\n                        }\n                        KeyCode::Char(c) => {\n                            if key.modifiers.contains(KeyModifiers::CONTROL)\n                                && key.code == KeyCode::Char('c')\n                            // ctrl+c to quit\n                            {\n                                break;\n                            }\n\n                            match app.state {\n                                AppState::Typing => {\n                                    if !app.thok.has_finished() {\n                                        app.thok.on_keypress_start();\n                                        app.thok.write(c);\n                                        if app.thok.has_finished() {\n                                            app.thok.calc_results();\n                                            app.state = AppState::Results;\n                                        }\n                                    }\n                                }\n                                AppState::Results => match key.code {\n                                    KeyCode::Char('t') => {\n                                        if Browser::is_available() {\n                                            webbrowser::open(&format!(\"https://twitter.com/intent/tweet?text={}%20wpm%20%2F%20{}%25%20acc%20%2F%20{:.2}%20sd%0A%0Ahttps%3A%2F%2Fgithub.com%thatvegandev%2Fthokr\", app.thok.wpm, app.thok.accuracy, app.thok.std_dev))\n                                        .unwrap_or_default();\n                                        }\n                                    }\n                                    KeyCode::Char('r') => {\n                                        exit_type = ExitType::Restart;\n                                        break;\n                                    }\n                                    KeyCode::Char('n') => {\n                                        exit_type = ExitType::New;\n                                        break;\n                                    }\n                                    KeyCode::Char('s') => {\n                                        app.state = AppState::CharacterStats;\n                                    }\n                                    _ => {}\n                                },\n                                AppState::CharacterStats => match key.code {\n                                    KeyCode::Char('r') => {\n                                        exit_type = ExitType::Restart;\n                                        break;\n                                    }\n                                    KeyCode::Char('n') => {\n                                        exit_type = ExitType::New;\n                                        break;\n                                    }\n                                    KeyCode::Char('b') | KeyCode::Backspace => {\n                                        app.state = AppState::Results;\n                                    }\n                                    KeyCode::Up => {\n                                        if app.char_stats_state.scroll_offset > 0 {\n                                            app.char_stats_state.scroll_offset -= 1;\n                                        }\n                                    }\n                                    KeyCode::Down => {\n                                        // Will check max scroll in render function\n                                        app.char_stats_state.scroll_offset += 1;\n                                    }\n                                    KeyCode::PageUp => {\n                                        app.char_stats_state.scroll_offset =\n                                            app.char_stats_state.scroll_offset.saturating_sub(10);\n                                    }\n                                    KeyCode::PageDown => {\n                                        app.char_stats_state.scroll_offset += 10;\n                                    }\n                                    KeyCode::Home => {\n                                        app.char_stats_state.scroll_offset = 0;\n                                    }\n                                    KeyCode::Char('1') => {\n                                        app.char_stats_state.sort_by = SortBy::Character;\n                                        app.char_stats_state.scroll_offset = 0;\n                                    }\n                                    KeyCode::Char('2') => {\n                                        app.char_stats_state.sort_by = SortBy::AvgTime;\n                                        app.char_stats_state.scroll_offset = 0;\n                                    }\n                                    KeyCode::Char('3') => {\n                                        app.char_stats_state.sort_by = SortBy::MissRate;\n                                        app.char_stats_state.scroll_offset = 0;\n                                    }\n                                    KeyCode::Char('4') => {\n                                        app.char_stats_state.sort_by = SortBy::Attempts;\n                                        app.char_stats_state.scroll_offset = 0;\n                                    }\n                                    KeyCode::Char(' ') => {\n                                        // Toggle sort direction\n                                        app.char_stats_state.sort_ascending =\n                                            !app.char_stats_state.sort_ascending;\n                                        app.char_stats_state.scroll_offset = 0;\n                                    }\n                                    _ => {}\n                                },\n                            }\n                        }\n                        _ => {}\n                    }\n                    terminal.draw(|f| ui(app, f))?;\n                }\n            }\n        }\n\n        match exit_type {\n            ExitType::Restart => {\n                app.reset(Some(app.thok.prompt.clone()));\n            }\n            ExitType::New => {\n                app.reset(None);\n            }\n            ExitType::Quit => {\n                break;\n            }\n        }\n    }\n\n    Ok(())\n}\n\n#[derive(Clone)]\nenum ThokEvent {\n    Key(KeyEvent),\n    Resize,\n    Tick,\n}\n\nfn get_thok_events(should_tick: bool) -> mpsc::Receiver<ThokEvent> {\n    let (tx, rx) = mpsc::channel();\n\n    if should_tick {\n        let tick_x = tx.clone();\n        thread::spawn(move || loop {\n            if tick_x.send(ThokEvent::Tick).is_err() {\n                break;\n            }\n\n            thread::sleep(Duration::from_millis(TICK_RATE_MS))\n        });\n    }\n\n    thread::spawn(move || loop {\n        let evt = match event::read().unwrap() {\n            Event::Key(key) => Some(ThokEvent::Key(key)),\n            Event::Resize(_, _) => Some(ThokEvent::Resize),\n            _ => None,\n        };\n\n        if evt.is_some() && tx.send(evt.unwrap()).is_err() {\n            break;\n        }\n    });\n\n    rx\n}\n\nfn render_character_stats(app: &mut App, f: &mut Frame) {\n    use ratatui::{\n        layout::{Alignment, Constraint, Direction, Layout},\n        style::{Color, Modifier, Style},\n        widgets::{Block, Borders, Cell, Paragraph, Row, Table},\n    };\n\n    let area = f.area();\n\n    // Create layout\n    let chunks = Layout::default()\n        .direction(Direction::Vertical)\n        .margin(2)\n        .constraints([\n            Constraint::Length(3), // Title\n            Constraint::Min(0),    // Stats table\n            Constraint::Length(4), // Instructions\n        ])\n        .split(area);\n\n    // Title with sort indicator\n    let sort_direction = if app.char_stats_state.sort_ascending {\n        \"\"\n    } else {\n        \"\"\n    };\n    let sort_by_text = match app.char_stats_state.sort_by {\n        SortBy::Character => \"Character\",\n        SortBy::AvgTime => \"Avg Time\",\n        SortBy::MissRate => \"Miss Rate\",\n        SortBy::Attempts => \"Attempts\",\n    };\n    let title_text = format!(\n        \"Character Statistics (Sort: {} {})\",\n        sort_by_text, sort_direction\n    );\n\n    let title = Paragraph::new(title_text)\n        .block(Block::default().borders(Borders::ALL).title(\"Stats\"))\n        .style(\n            Style::default()\n                .fg(Color::Cyan)\n                .add_modifier(Modifier::BOLD),\n        )\n        .alignment(Alignment::Center);\n    f.render_widget(title, chunks[0]);\n\n    // Get character statistics\n    if let Some(mut summary) = app.thok.get_all_char_summary() {\n        // Sort the data based on current sort criteria\n        match app.char_stats_state.sort_by {\n            SortBy::Character => {\n                summary.sort_by(|a, b| {\n                    let cmp = a.0.cmp(&b.0);\n                    if app.char_stats_state.sort_ascending {\n                        cmp\n                    } else {\n                        cmp.reverse()\n                    }\n                });\n            }\n            SortBy::AvgTime => {\n                summary.sort_by(|a, b| {\n                    let cmp = a.1.partial_cmp(&b.1).unwrap_or(std::cmp::Ordering::Equal);\n                    if app.char_stats_state.sort_ascending {\n                        cmp\n                    } else {\n                        cmp.reverse()\n                    }\n                });\n            }\n            SortBy::MissRate => {\n                summary.sort_by(|a, b| {\n                    let cmp = a.2.partial_cmp(&b.2).unwrap_or(std::cmp::Ordering::Equal);\n                    if app.char_stats_state.sort_ascending {\n                        cmp\n                    } else {\n                        cmp.reverse()\n                    }\n                });\n            }\n            SortBy::Attempts => {\n                summary.sort_by(|a, b| {\n                    let cmp = a.3.cmp(&b.3);\n                    if app.char_stats_state.sort_ascending {\n                        cmp\n                    } else {\n                        cmp.reverse()\n                    }\n                });\n            }\n        }\n\n        // Calculate scrolling bounds\n        let table_height = chunks[1].height.saturating_sub(3) as usize; // Account for borders and header\n        let total_rows = summary.len();\n        let max_scroll = total_rows.saturating_sub(table_height);\n\n        // Clamp scroll offset\n        if app.char_stats_state.scroll_offset > max_scroll {\n            app.char_stats_state.scroll_offset = max_scroll;\n        }\n\n        // Create header with sort indicators\n        let char_indicator = if matches!(app.char_stats_state.sort_by, SortBy::Character) {\n            sort_direction\n        } else {\n            \"\"\n        };\n        let time_indicator = if matches!(app.char_stats_state.sort_by, SortBy::AvgTime) {\n            sort_direction\n        } else {\n            \"\"\n        };\n        let miss_indicator = if matches!(app.char_stats_state.sort_by, SortBy::MissRate) {\n            sort_direction\n        } else {\n            \"\"\n        };\n        let attempts_indicator = if matches!(app.char_stats_state.sort_by, SortBy::Attempts) {\n            sort_direction\n        } else {\n            \"\"\n        };\n\n        let header = Row::new(vec![\n            Cell::from(format!(\"Char {}\", char_indicator)),\n            Cell::from(format!(\"Avg Time (ms) {}\", time_indicator)),\n            Cell::from(format!(\"Miss Rate (%) {}\", miss_indicator)),\n            Cell::from(format!(\"Attempts {}\", attempts_indicator)),\n        ])\n        .style(\n            Style::default()\n                .fg(Color::Yellow)\n                .add_modifier(Modifier::BOLD),\n        );\n\n        // Get visible rows based on scroll offset\n        let visible_rows: Vec<Row> = summary\n            .iter()\n            .skip(app.char_stats_state.scroll_offset)\n            .take(table_height)\n            .map(|(character, avg_time, miss_rate, attempts)| {\n                let char_display = if *character == ' ' {\n                    \"SPACE\".to_string()\n                } else {\n                    character.to_string()\n                };\n\n                let time_color = if *avg_time < 150.0 {\n                    Color::Green\n                } else if *avg_time < 250.0 {\n                    Color::Yellow\n                } else {\n                    Color::Red\n                };\n\n                let miss_color = if *miss_rate == 0.0 {\n                    Color::Green\n                } else if *miss_rate < 10.0 {\n                    Color::Yellow\n                } else {\n                    Color::Red\n                };\n\n                Row::new(vec![\n                    Cell::from(char_display),\n                    Cell::from(format!(\"{:.1}\", avg_time)).style(Style::default().fg(time_color)),\n                    Cell::from(format!(\"{:.1}\", miss_rate)).style(Style::default().fg(miss_color)),\n                    Cell::from(attempts.to_string()),\n                ])\n            })\n            .collect();\n\n        // Show scroll position in title if there are more rows than visible\n        let scroll_info = if total_rows > table_height {\n            format!(\n                \" ({}/{} rows)\",\n                app.char_stats_state.scroll_offset + visible_rows.len().min(table_height),\n                total_rows\n            )\n        } else {\n            String::new()\n        };\n\n        let table = Table::new(\n            visible_rows,\n            &[\n                Constraint::Length(8),\n                Constraint::Length(18),\n                Constraint::Length(18),\n                Constraint::Length(12),\n            ],\n        )\n        .header(header)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .title(format!(\"Performance by Character{}\", scroll_info)),\n        )\n        .row_highlight_style(Style::default().bg(Color::DarkGray));\n\n        f.render_widget(table, chunks[1]);\n    } else {\n        let no_data = Paragraph::new(\n            \"No character statistics available.\\nComplete a typing test to see your stats!\",\n        )\n        .block(Block::default().borders(Borders::ALL).title(\"No Data\"))\n        .style(Style::default().fg(Color::Gray))\n        .alignment(Alignment::Center);\n        f.render_widget(no_data, chunks[1]);\n    }\n\n    // Instructions\n    let instructions = Paragraph::new(\"Sort: (1)Char (2)Time (3)Miss (4)Attempts | (Space)Toggle direction\\nScroll: / PgUp/PgDn Home | (b)ack (r)etry (n)ew (esc)ape\")\n        .block(Block::default().borders(Borders::ALL))\n        .style(Style::default().fg(Color::Gray).add_modifier(Modifier::ITALIC))\n        .alignment(Alignment::Center);\n    f.render_widget(instructions, chunks[2]);\n}\n\nfn ui(app: &mut App, f: &mut Frame) {\n    match app.state {\n        AppState::Typing | AppState::Results => {\n            f.render_widget(&app.thok, f.area());\n        }\n        AppState::CharacterStats => {\n            render_character_stats(app, f);\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use clap::Parser;\n\n    #[test]\n    fn test_cli_default_values() {\n        let cli = Cli::parse_from([\"thokr\"]);\n\n        assert_eq!(cli.number_of_words, 15);\n        assert_eq!(cli.number_of_sentences, None);\n        assert_eq!(cli.number_of_secs, None);\n        assert_eq!(cli.prompt, None);\n        assert!(matches!(cli.supported_language, SupportedLanguage::English));\n    }\n\n    #[test]\n    fn test_cli_number_of_words() {\n        let cli = Cli::parse_from([\"thokr\", \"-w\", \"25\"]);\n        assert_eq!(cli.number_of_words, 25);\n\n        let cli = Cli::parse_from([\"thokr\", \"--number-of-words\", \"50\"]);\n        assert_eq!(cli.number_of_words, 50);\n    }\n\n    #[test]\n    fn test_cli_number_of_sentences() {\n        let cli = Cli::parse_from([\"thokr\", \"-f\", \"3\"]);\n        assert_eq!(cli.number_of_sentences, Some(3));\n\n        let cli = Cli::parse_from([\"thokr\", \"--full-sentences\", \"5\"]);\n        assert_eq!(cli.number_of_sentences, Some(5));\n    }\n\n    #[test]\n    fn test_cli_number_of_secs() {\n        let cli = Cli::parse_from([\"thokr\", \"-s\", \"60\"]);\n        assert_eq!(cli.number_of_secs, Some(60));\n\n        let cli = Cli::parse_from([\"thokr\", \"--number-of-secs\", \"120\"]);\n        assert_eq!(cli.number_of_secs, Some(120));\n    }\n\n    #[test]\n    fn test_cli_custom_prompt() {\n        let cli = Cli::parse_from([\"thokr\", \"-p\", \"hello world\"]);\n        assert_eq!(cli.prompt, Some(\"hello world\".to_string()));\n\n        let cli = Cli::parse_from([\"thokr\", \"--prompt\", \"custom text\"]);\n        assert_eq!(cli.prompt, Some(\"custom text\".to_string()));\n    }\n\n    #[test]\n    fn test_cli_supported_language() {\n        let cli = Cli::parse_from([\"thokr\", \"-l\", \"english\"]);\n        assert!(matches!(cli.supported_language, SupportedLanguage::English));\n\n        let cli = Cli::parse_from([\"thokr\", \"--supported-language\", \"english1k\"]);\n        assert!(matches!(\n            cli.supported_language,\n            SupportedLanguage::English1k\n        ));\n\n        let cli = Cli::parse_from([\"thokr\", \"--supported-language\", \"english10k\"]);\n        assert!(matches!(\n            cli.supported_language,\n            SupportedLanguage::English10k\n        ));\n    }\n\n    #[test]\n    fn test_supported_language_as_lang() {\n        let english = SupportedLanguage::English.as_lang();\n        assert_eq!(english.name, \"english\");\n\n        let english1k = SupportedLanguage::English1k.as_lang();\n        assert_eq!(english1k.name, \"english_1k\");\n\n        let english10k = SupportedLanguage::English10k.as_lang();\n        assert_eq!(english10k.name, \"english_10k\");\n    }\n\n    #[test]\n    fn test_supported_language_display() {\n        assert_eq!(SupportedLanguage::English.to_string(), \"English\");\n        assert_eq!(SupportedLanguage::English1k.to_string(), \"English1k\");\n        assert_eq!(SupportedLanguage::English10k.to_string(), \"English10k\");\n    }\n\n    #[test]\n    fn test_app_new_with_words() {\n        let cli = Cli {\n            number_of_words: 10,\n            number_of_sentences: None,\n            number_of_secs: None,\n            prompt: None,\n            supported_language: SupportedLanguage::English,\n            random_words: false,\n            capitalize: false,\n            strict: false,\n            symbols: false,\n            substitute: false,\n        };\n\n        let app = App::new(cli.clone());\n\n        assert_eq!(app.thok.number_of_words, 10);\n        assert_eq!(app.thok.number_of_secs, None);\n        assert!(app.cli.is_some());\n        assert!(!app.thok.prompt.is_empty());\n        assert_eq!(app.state, AppState::Typing);\n    }\n\n    #[test]\n    fn test_app_new_with_custom_prompt() {\n        let cli = Cli {\n            number_of_words: 10,\n            number_of_sentences: None,\n            number_of_secs: None,\n            prompt: Some(\"custom test prompt\".to_string()),\n            supported_language: SupportedLanguage::English,\n            random_words: false,\n            capitalize: false,\n            strict: false,\n            symbols: false,\n            substitute: false,\n        };\n\n        let app = App::new(cli);\n\n        assert_eq!(app.thok.prompt, \"custom test prompt\");\n        assert_eq!(app.thok.number_of_words, 10);\n        assert_eq!(app.state, AppState::Typing);\n    }\n\n    #[test]\n    fn test_app_new_with_sentences() {\n        let cli = Cli {\n            number_of_words: 10,\n            number_of_sentences: Some(2),\n            number_of_secs: None,\n            prompt: None,\n            supported_language: SupportedLanguage::English,\n            random_words: false,\n            capitalize: false,\n            strict: false,\n            symbols: false,\n            substitute: false,\n        };\n\n        let app = App::new(cli);\n\n        assert!(app.thok.number_of_words > 0);\n        assert!(!app.thok.prompt.is_empty());\n        assert_eq!(app.state, AppState::Typing);\n    }\n\n    #[test]\n    fn test_app_new_with_time_limit() {\n        let cli = Cli {\n            number_of_words: 10,\n            number_of_sentences: None,\n            number_of_secs: Some(60),\n            prompt: None,\n            supported_language: SupportedLanguage::English,\n            random_words: false,\n            capitalize: false,\n            strict: false,\n            symbols: false,\n            substitute: false,\n        };\n\n        let app = App::new(cli);\n\n        assert_eq!(app.thok.number_of_secs, Some(60.0));\n        assert_eq!(app.thok.seconds_remaining, Some(60.0));\n        assert_eq!(app.state, AppState::Typing);\n    }\n\n    #[test]\n    fn test_app_reset_with_new_prompt() {\n        let cli = Cli {\n            number_of_words: 5,\n            number_of_sentences: None,\n            number_of_secs: None,\n            prompt: None,\n            supported_language: SupportedLanguage::English,\n            random_words: false,\n            capitalize: false,\n            strict: false,\n            symbols: false,\n            substitute: false,\n        };\n\n        let mut app = App::new(cli);\n        let original_prompt = app.thok.prompt.clone();\n\n        app.reset(Some(\"new test prompt\".to_string()));\n\n        assert_eq!(app.thok.prompt, \"new test prompt\");\n        assert_ne!(app.thok.prompt, original_prompt);\n        assert_eq!(app.thok.input.len(), 0);\n        assert_eq!(app.thok.cursor_pos, 0);\n        assert_eq!(app.state, AppState::Typing);\n    }\n\n    #[test]\n    fn test_app_reset_without_new_prompt() {\n        let cli = Cli {\n            number_of_words: 5,\n            number_of_sentences: None,\n            number_of_secs: None,\n            prompt: None,\n            supported_language: SupportedLanguage::English,\n            random_words: false,\n            capitalize: false,\n            strict: false,\n            symbols: false,\n            substitute: false,\n        };\n\n        let mut app = App::new(cli);\n        let original_prompt = app.thok.prompt.clone();\n\n        app.thok.write('t');\n        app.thok.write('e');\n        assert_eq!(app.thok.input.len(), 2);\n\n        app.reset(None);\n\n        assert_ne!(app.thok.prompt, original_prompt);\n        assert_eq!(app.thok.input.len(), 0);\n        assert_eq!(app.thok.cursor_pos, 0);\n        assert_eq!(app.state, AppState::Typing);\n    }\n\n    #[test]\n    fn test_thok_event_clone() {\n        let key_event = KeyEvent::new(KeyCode::Char('a'), KeyModifiers::NONE);\n        let thok_event = ThokEvent::Key(key_event);\n        let cloned_event = thok_event.clone();\n\n        match (thok_event, cloned_event) {\n            (ThokEvent::Key(original), ThokEvent::Key(cloned)) => {\n                assert_eq!(original.code, cloned.code);\n                assert_eq!(original.modifiers, cloned.modifiers);\n            }\n            _ => panic!(\"Events should match\"),\n        }\n    }\n\n    #[test]\n    fn test_exit_type_debug() {\n        let restart = ExitType::Restart;\n        let new = ExitType::New;\n        let quit = ExitType::Quit;\n\n        assert_eq!(format!(\"{:?}\", restart), \"Restart\");\n        assert_eq!(format!(\"{:?}\", new), \"New\");\n        assert_eq!(format!(\"{:?}\", quit), \"Quit\");\n    }\n\n    #[test]\n    fn test_app_state_transitions() {\n        let cli = Cli {\n            number_of_words: 3,\n            number_of_sentences: None,\n            number_of_secs: None,\n            prompt: Some(\"hello\".to_string()),\n            supported_language: SupportedLanguage::English,\n            random_words: false,\n            capitalize: false,\n            strict: false,\n            symbols: false,\n            substitute: false,\n        };\n\n        let mut app = App::new(cli);\n\n        // Should start in Typing state\n        assert_eq!(app.state, AppState::Typing);\n\n        // Simulate completing the typing test\n        app.thok.write('h');\n        app.thok.write('e');\n        app.thok.write('l');\n        app.thok.write('l');\n        app.thok.write('o');\n\n        assert!(app.thok.has_finished());\n        app.thok.calc_results();\n        app.state = AppState::Results;\n\n        assert_eq!(app.state, AppState::Results);\n\n        // Navigate to character stats\n        app.state = AppState::CharacterStats;\n        assert_eq!(app.state, AppState::CharacterStats);\n\n        // Navigate back to results\n        app.state = AppState::Results;\n        assert_eq!(app.state, AppState::Results);\n    }\n\n    #[test]\n    fn test_app_state_clone() {\n        let state1 = AppState::Typing;\n        let state2 = state1.clone();\n        assert_eq!(state1, state2);\n\n        let state3 = AppState::CharacterStats;\n        assert_ne!(state1, state3);\n    }\n\n    #[test]\n    fn test_flag_independence_at_app_level() {\n        // Test that CLI flags control their own behavior independently\n\n        // Test substitute only\n        let cli_substitute_only = Cli {\n            number_of_words: 5,\n            number_of_sentences: None,\n            number_of_secs: None,\n            prompt: None,\n            supported_language: SupportedLanguage::English,\n            random_words: false,\n            capitalize: false,\n            strict: false,\n            symbols: false,\n            substitute: true,\n        };\n        let app_substitute = App::new(cli_substitute_only);\n        // Should generate substituted words without extra formatting\n        assert!(!app_substitute.thok.prompt.is_empty());\n\n        // Test capitalize only\n        let cli_capitalize_only = Cli {\n            number_of_words: 5,\n            number_of_sentences: None,\n            number_of_secs: None,\n            prompt: None,\n            supported_language: SupportedLanguage::English,\n            random_words: false,\n            capitalize: true,\n            strict: false,\n            symbols: false,\n            substitute: false,\n        };\n        let app_capitalize = App::new(cli_capitalize_only);\n        // Should have capitalization\n        assert!(app_capitalize\n            .thok\n            .prompt\n            .chars()\n            .next()\n            .unwrap()\n            .is_uppercase());\n\n        // Test symbols only\n        let cli_symbols_only = Cli {\n            number_of_words: 5,\n            number_of_sentences: None,\n            number_of_secs: None,\n            prompt: None,\n            supported_language: SupportedLanguage::English,\n            random_words: false,\n            capitalize: false,\n            strict: false,\n            symbols: true,\n            substitute: false,\n        };\n        let app_symbols = App::new(cli_symbols_only);\n        // Should have symbols available (end punctuation at minimum)\n        assert!(\n            app_symbols.thok.prompt.ends_with('.')\n                || app_symbols.thok.prompt.ends_with('!')\n                || app_symbols.thok.prompt.ends_with('?')\n                || app_symbols.thok.prompt.ends_with(';')\n                || app_symbols.thok.prompt.ends_with(':')\n                || app_symbols.thok.prompt.ends_with(\"...\")\n        );\n\n        // Test all three combined\n        let cli_all = Cli {\n            number_of_words: 5,\n            number_of_sentences: None,\n            number_of_secs: None,\n            prompt: None,\n            supported_language: SupportedLanguage::English,\n            random_words: false,\n            capitalize: true,\n            strict: false,\n            symbols: true,\n            substitute: true,\n        };\n        let app_all = App::new(cli_all);\n        // Should have all features\n        assert!(!app_all.thok.prompt.is_empty());\n        // Due to substitution and symbol randomness, just check that the prompt is generated\n        // The capitalization will be handled by the formatting logic when both flags are enabled\n    }\n\n    #[test]\n    fn test_cli_to_word_gen_config() {\n        let cli = Cli {\n            number_of_words: 20,\n            number_of_sentences: Some(3),\n            number_of_secs: Some(60),\n            prompt: Some(\"test prompt\".to_string()),\n            supported_language: SupportedLanguage::English1k,\n            random_words: true,\n            capitalize: true,\n            strict: false,\n            symbols: true,\n            substitute: false,\n        };\n\n        let config = cli.to_word_gen_config(None);\n\n        assert_eq!(config.number_of_words, 20);\n        assert_eq!(config.number_of_sentences, Some(3));\n        assert_eq!(config.custom_prompt, None);\n        assert!(matches!(config.language, SupportedLanguage::English1k));\n        assert!(config.random_words);\n        assert!(config.capitalize);\n        assert!(config.symbols);\n        assert!(!config.substitute);\n    }\n\n    #[test]\n    fn test_cli_to_word_gen_config_with_custom_prompt() {\n        let cli = Cli {\n            number_of_words: 10,\n            number_of_sentences: None,\n            number_of_secs: None,\n            prompt: None,\n            supported_language: SupportedLanguage::English,\n            random_words: false,\n            capitalize: false,\n            strict: false,\n            symbols: false,\n            substitute: false,\n        };\n\n        let config = cli.to_word_gen_config(Some(\"custom prompt override\".to_string()));\n\n        assert_eq!(\n            config.custom_prompt,\n            Some(\"custom prompt override\".to_string())\n        );\n    }\n\n    #[test]\n    fn test_char_stats_state_default() {\n        let state = CharStatsState::default();\n\n        assert_eq!(state.scroll_offset, 0);\n        assert!(matches!(state.sort_by, SortBy::Character));\n        assert!(state.sort_ascending);\n    }\n\n    #[test]\n    fn test_sort_by_variants() {\n        // Test that all SortBy variants can be created\n        let _char_sort = SortBy::Character;\n        let _time_sort = SortBy::AvgTime;\n        let _miss_sort = SortBy::MissRate;\n        let _attempts_sort = SortBy::Attempts;\n    }\n\n    #[test]\n    fn test_app_state_variants() {\n        // Test that all AppState variants can be created and are equal to themselves\n        assert_eq!(AppState::Typing, AppState::Typing);\n        assert_eq!(AppState::Results, AppState::Results);\n        assert_eq!(AppState::CharacterStats, AppState::CharacterStats);\n\n        // Test that different variants are not equal\n        assert_ne!(AppState::Typing, AppState::Results);\n        assert_ne!(AppState::Results, AppState::CharacterStats);\n    }\n\n    #[test]\n    fn test_strict_mode_flag() {\n        let cli_strict = Cli {\n            number_of_words: 5,\n            number_of_sentences: None,\n            number_of_secs: None,\n            prompt: Some(\"test\".to_string()),\n            supported_language: SupportedLanguage::English,\n            random_words: false,\n            capitalize: false,\n            strict: true,\n            symbols: false,\n            substitute: false,\n        };\n\n        let app = App::new(cli_strict);\n        assert!(app.thok.strict_mode);\n    }\n\n    #[test]\n    fn test_supported_language_enum_variants() {\n        // Test all variants can be created\n        let _english = SupportedLanguage::English;\n        let _english1k = SupportedLanguage::English1k;\n        let _english10k = SupportedLanguage::English10k;\n\n        // Test copying\n        let lang1 = SupportedLanguage::English;\n        let lang2 = lang1;\n        assert!(matches!(lang2, SupportedLanguage::English));\n    }\n}\n","traces":[{"line":95,"address":[],"length":0,"stats":{"Line":21}},{"line":96,"address":[],"length":0,"stats":{"Line":21}},{"line":102,"address":[],"length":0,"stats":{"Line":16}},{"line":104,"address":[],"length":0,"stats":{"Line":16}},{"line":105,"address":[],"length":0,"stats":{"Line":16}},{"line":107,"address":[],"length":0,"stats":{"Line":16}},{"line":108,"address":[],"length":0,"stats":{"Line":16}},{"line":109,"address":[],"length":0,"stats":{"Line":16}},{"line":110,"address":[],"length":0,"stats":{"Line":16}},{"line":111,"address":[],"length":0,"stats":{"Line":16}},{"line":139,"address":[],"length":0,"stats":{"Line":15}},{"line":157,"address":[],"length":0,"stats":{"Line":12}},{"line":158,"address":[],"length":0,"stats":{"Line":12}},{"line":159,"address":[],"length":0,"stats":{"Line":12}},{"line":160,"address":[],"length":0,"stats":{"Line":12}},{"line":163,"address":[],"length":0,"stats":{"Line":12}},{"line":169,"address":[],"length":0,"stats":{"Line":12}},{"line":171,"address":[],"length":0,"stats":{"Line":12}},{"line":175,"address":[],"length":0,"stats":{"Line":2}},{"line":176,"address":[],"length":0,"stats":{"Line":2}},{"line":177,"address":[],"length":0,"stats":{"Line":2}},{"line":178,"address":[],"length":0,"stats":{"Line":2}},{"line":179,"address":[],"length":0,"stats":{"Line":2}},{"line":181,"address":[],"length":0,"stats":{"Line":2}},{"line":182,"address":[],"length":0,"stats":{"Line":2}},{"line":183,"address":[],"length":0,"stats":{"Line":2}},{"line":184,"address":[],"length":0,"stats":{"Line":4}},{"line":185,"address":[],"length":0,"stats":{"Line":2}},{"line":187,"address":[],"length":0,"stats":{"Line":2}},{"line":188,"address":[],"length":0,"stats":{"Line":2}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":482,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":513,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":537,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":0}},{"line":540,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":545,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":554,"address":[],"length":0,"stats":{"Line":0}},{"line":555,"address":[],"length":0,"stats":{"Line":0}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":557,"address":[],"length":0,"stats":{"Line":0}},{"line":560,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":562,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[],"length":0,"stats":{"Line":0}},{"line":568,"address":[],"length":0,"stats":{"Line":0}},{"line":569,"address":[],"length":0,"stats":{"Line":0}},{"line":570,"address":[],"length":0,"stats":{"Line":0}},{"line":571,"address":[],"length":0,"stats":{"Line":0}},{"line":572,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":577,"address":[],"length":0,"stats":{"Line":0}},{"line":578,"address":[],"length":0,"stats":{"Line":0}},{"line":579,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":582,"address":[],"length":0,"stats":{"Line":0}},{"line":585,"address":[],"length":0,"stats":{"Line":0}},{"line":586,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":588,"address":[],"length":0,"stats":{"Line":0}},{"line":590,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":594,"address":[],"length":0,"stats":{"Line":0}},{"line":595,"address":[],"length":0,"stats":{"Line":0}},{"line":596,"address":[],"length":0,"stats":{"Line":0}},{"line":597,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[],"length":0,"stats":{"Line":0}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":606,"address":[],"length":0,"stats":{"Line":0}},{"line":607,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":0}},{"line":614,"address":[],"length":0,"stats":{"Line":0}},{"line":615,"address":[],"length":0,"stats":{"Line":0}},{"line":616,"address":[],"length":0,"stats":{"Line":0}},{"line":617,"address":[],"length":0,"stats":{"Line":0}},{"line":618,"address":[],"length":0,"stats":{"Line":0}},{"line":619,"address":[],"length":0,"stats":{"Line":0}},{"line":622,"address":[],"length":0,"stats":{"Line":0}},{"line":624,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":635,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[],"length":0,"stats":{"Line":0}},{"line":637,"address":[],"length":0,"stats":{"Line":0}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":642,"address":[],"length":0,"stats":{"Line":0}},{"line":643,"address":[],"length":0,"stats":{"Line":0}},{"line":644,"address":[],"length":0,"stats":{"Line":0}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":646,"address":[],"length":0,"stats":{"Line":0}},{"line":649,"address":[],"length":0,"stats":{"Line":0}},{"line":650,"address":[],"length":0,"stats":{"Line":0}},{"line":651,"address":[],"length":0,"stats":{"Line":0}},{"line":652,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":0}},{"line":655,"address":[],"length":0,"stats":{"Line":0}}],"covered":30,"coverable":298},{"path":["/","Users","martintrojer","hacking","thokr","src","stats.rs"],"content":"use chrono::{DateTime, Local};\nuse directories::ProjectDirs;\nuse rusqlite::{params, Connection, Result};\nuse std::collections::HashMap;\nuse std::path::PathBuf;\nuse std::time::SystemTime;\n\nuse crate::language::CharacterDifficulty;\n\n/// Character-level statistics for tracking typing performance (used during session)\n#[derive(Debug, Clone)]\npub struct CharStat {\n    pub character: char, // The base character (always lowercase for letters)\n    pub time_to_press_ms: u64,\n    pub was_correct: bool,\n    pub was_uppercase: bool, // True if the original character was uppercase\n    pub timestamp: DateTime<Local>,\n    pub context_before: String,\n    pub context_after: String,\n}\n\n/// Aggregated statistics for a character across multiple attempts in a session\n#[derive(Debug, Clone)]\npub struct CharSessionStats {\n    pub character: char,       // Base character (lowercase)\n    pub total_attempts: u32,   // Total attempts for this character (any case)\n    pub correct_attempts: u32, // Correct attempts for this character (any case)\n    pub total_time_ms: u64,    // Total time for correct attempts (any case)\n    pub min_time_ms: u64,      // Fastest time for any case\n    pub max_time_ms: u64,      // Slowest time for any case\n    // Uppercase-specific metrics\n    pub uppercase_attempts: u32, // Total uppercase attempts\n    pub uppercase_correct: u32,  // Correct uppercase attempts\n    pub uppercase_time_ms: u64,  // Total time for correct uppercase attempts\n    pub uppercase_min_time: u64, // Fastest uppercase time\n    pub uppercase_max_time: u64, // Slowest uppercase time\n}\n\n/// Database manager for character statistics\n#[derive(Debug)]\npub struct StatsDb {\n    conn: Connection,\n    session_buffer: HashMap<char, Vec<CharStat>>,\n}\n\nimpl StatsDb {\n    /// Initialize the database connection and create tables if needed\n    pub fn new() -> Result<Self> {\n        let db_path = Self::get_db_path().unwrap_or_else(|| PathBuf::from(\"thokr_stats.db\"));\n\n        // Create parent directory if it doesn't exist\n        if let Some(parent) = db_path.parent() {\n            std::fs::create_dir_all(parent).map_err(|e| {\n                rusqlite::Error::SqliteFailure(\n                    rusqlite::ffi::Error::new(rusqlite::ffi::SQLITE_CANTOPEN),\n                    Some(format!(\"Failed to create directory: {}\", e)),\n                )\n            })?;\n        }\n\n        let conn = Connection::open(&db_path)?;\n\n        // Create the aggregated character statistics table\n        conn.execute(\n            r#\"\n            CREATE TABLE IF NOT EXISTS char_session_stats (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                character TEXT NOT NULL,\n                total_attempts INTEGER NOT NULL,\n                correct_attempts INTEGER NOT NULL,\n                total_time_ms INTEGER NOT NULL,\n                min_time_ms INTEGER NOT NULL,\n                max_time_ms INTEGER NOT NULL,\n                uppercase_attempts INTEGER NOT NULL DEFAULT 0,\n                uppercase_correct INTEGER NOT NULL DEFAULT 0,\n                uppercase_time_ms INTEGER NOT NULL DEFAULT 0,\n                uppercase_min_time INTEGER NOT NULL DEFAULT 0,\n                uppercase_max_time INTEGER NOT NULL DEFAULT 0,\n                session_date TEXT NOT NULL,\n                created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n            )\n            \"#,\n            [],\n        )?;\n\n        // Create index for faster queries\n        conn.execute(\n            \"CREATE INDEX IF NOT EXISTS idx_char_session_stats_char ON char_session_stats(character)\",\n            [],\n        )?;\n\n        conn.execute(\n            \"CREATE INDEX IF NOT EXISTS idx_char_session_stats_date ON char_session_stats(session_date)\",\n            [],\n        )?;\n\n        Ok(StatsDb {\n            conn,\n            session_buffer: HashMap::new(),\n        })\n    }\n\n    /// Get the database file path under $HOME/.local/state/thokr\n    fn get_db_path() -> Option<PathBuf> {\n        // Try to use the XDG-compliant ~/.local/state directory first\n        if let Ok(home) = std::env::var(\"HOME\") {\n            let state_dir = PathBuf::from(home)\n                .join(\".local\")\n                .join(\"state\")\n                .join(\"thokr\");\n            Some(state_dir.join(\"stats.db\"))\n        } else if let Some(proj_dirs) = ProjectDirs::from(\"\", \"\", \"thokr\") {\n            // Fallback to system-specific directory\n            let state_dir = proj_dirs.data_local_dir();\n            Some(state_dir.join(\"stats.db\"))\n        } else {\n            None\n        }\n    }\n\n    /// Record a character statistic (buffers for session aggregation)\n    pub fn record_char_stat(&mut self, stat: &CharStat) -> Result<()> {\n        self.session_buffer\n            .entry(stat.character)\n            .or_default()\n            .push(stat.clone());\n        Ok(())\n    }\n\n    /// Record aggregated session statistics for characters\n    pub fn record_session_stats(&self, session_stats: &[CharSessionStats]) -> Result<()> {\n        let session_date = Local::now().format(\"%Y-%m-%d\").to_string();\n\n        for stat in session_stats {\n            self.conn.execute(\n                r#\"\n                INSERT INTO char_session_stats \n                (character, total_attempts, correct_attempts, total_time_ms, min_time_ms, max_time_ms, \n                 uppercase_attempts, uppercase_correct, uppercase_time_ms, uppercase_min_time, uppercase_max_time, session_date)\n                VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11, ?12)\n                \"#,\n                params![\n                    stat.character.to_string(),\n                    stat.total_attempts,\n                    stat.correct_attempts,\n                    stat.total_time_ms,\n                    stat.min_time_ms,\n                    stat.max_time_ms,\n                    stat.uppercase_attempts,\n                    stat.uppercase_correct,\n                    stat.uppercase_time_ms,\n                    stat.uppercase_min_time,\n                    stat.uppercase_max_time,\n                    session_date,\n                ],\n            )?;\n        }\n\n        Ok(())\n    }\n\n    /// Flush session buffer to database with aggregated statistics\n    pub fn flush(&mut self) -> Result<()> {\n        if self.session_buffer.is_empty() {\n            return Ok(());\n        }\n\n        // Aggregate all buffered stats\n        let session_stats = Self::aggregate_char_stats_from_buffer(&self.session_buffer);\n\n        // Record to database\n        self.record_session_stats(&session_stats)?;\n\n        // Clear buffer\n        self.session_buffer.clear();\n\n        Ok(())\n    }\n\n    /// Record multiple character statistics in a batch transaction (aggregated)\n    pub fn record_char_stats_batch(&mut self, stats: &[CharStat]) -> Result<()> {\n        // Add to session buffer\n        for stat in stats {\n            self.record_char_stat(stat)?;\n        }\n\n        // Immediately flush for session end\n        self.flush()\n    }\n\n    /// Aggregate buffered character statistics into session summaries\n    fn aggregate_char_stats_from_buffer(\n        buffer: &HashMap<char, Vec<CharStat>>,\n    ) -> Vec<CharSessionStats> {\n        let mut session_stats = Vec::new();\n\n        for (&character, stats) in buffer {\n            let mut char_session = CharSessionStats {\n                character,\n                total_attempts: 0,\n                correct_attempts: 0,\n                total_time_ms: 0,\n                min_time_ms: u64::MAX,\n                max_time_ms: 0,\n                uppercase_attempts: 0,\n                uppercase_correct: 0,\n                uppercase_time_ms: 0,\n                uppercase_min_time: u64::MAX,\n                uppercase_max_time: 0,\n            };\n\n            for stat in stats {\n                char_session.total_attempts += 1;\n\n                if stat.was_uppercase {\n                    char_session.uppercase_attempts += 1;\n                }\n\n                if stat.was_correct {\n                    char_session.correct_attempts += 1;\n                    char_session.total_time_ms += stat.time_to_press_ms;\n                    char_session.min_time_ms = char_session.min_time_ms.min(stat.time_to_press_ms);\n                    char_session.max_time_ms = char_session.max_time_ms.max(stat.time_to_press_ms);\n\n                    if stat.was_uppercase {\n                        char_session.uppercase_correct += 1;\n                        char_session.uppercase_time_ms += stat.time_to_press_ms;\n                        char_session.uppercase_min_time =\n                            char_session.uppercase_min_time.min(stat.time_to_press_ms);\n                        char_session.uppercase_max_time =\n                            char_session.uppercase_max_time.max(stat.time_to_press_ms);\n                    }\n                }\n            }\n\n            // Fix min_time_ms for characters with no correct attempts\n            if char_session.correct_attempts == 0 {\n                char_session.min_time_ms = 0;\n            }\n            if char_session.uppercase_correct == 0 {\n                char_session.uppercase_min_time = 0;\n            }\n\n            session_stats.push(char_session);\n        }\n\n        session_stats\n    }\n\n    /// Get session statistics for a specific character\n    pub fn get_char_stats(&self, _character: char) -> Result<Vec<CharStat>> {\n        // Return empty for now since we're moving to aggregated data\n        // This maintains API compatibility but reduces storage\n        Ok(Vec::new())\n    }\n\n    /// Get session-based statistics for a specific character\n    pub fn get_char_session_stats(&self, character: char) -> Result<Vec<CharSessionStats>> {\n        let mut stmt = self.conn.prepare(\n            r#\"\n            SELECT character, total_attempts, correct_attempts, total_time_ms, min_time_ms, max_time_ms,\n                   uppercase_attempts, uppercase_correct, uppercase_time_ms, uppercase_min_time, uppercase_max_time\n            FROM char_session_stats \n            WHERE character = ?1\n            ORDER BY session_date DESC\n            \"#,\n        )?;\n\n        let stat_iter = stmt.query_map([character.to_string()], |row| {\n            Ok(CharSessionStats {\n                character: row.get::<_, String>(0)?.chars().next().unwrap_or('\\0'),\n                total_attempts: row.get(1)?,\n                correct_attempts: row.get(2)?,\n                total_time_ms: row.get(3)?,\n                min_time_ms: row.get(4)?,\n                max_time_ms: row.get(5)?,\n                uppercase_attempts: row.get(6)?,\n                uppercase_correct: row.get(7)?,\n                uppercase_time_ms: row.get(8)?,\n                uppercase_min_time: row.get(9)?,\n                uppercase_max_time: row.get(10)?,\n            })\n        })?;\n\n        let mut stats = Vec::new();\n        for stat in stat_iter {\n            stats.push(stat?);\n        }\n\n        Ok(stats)\n    }\n\n    /// Get average time to press for a character (from aggregated session data)\n    pub fn get_avg_time_to_press(&self, character: char) -> Result<Option<f64>> {\n        let mut stmt = self.conn.prepare(\n            r#\"\n            SELECT SUM(total_time_ms), SUM(correct_attempts)\n            FROM char_session_stats \n            WHERE character = ?1 AND correct_attempts > 0\n            \"#,\n        )?;\n\n        let result: Result<(Option<i64>, Option<i64>), _> = stmt\n            .query_row([character.to_string()], |row| {\n                Ok((row.get(0)?, row.get(1)?))\n            });\n\n        match result {\n            Ok((Some(total_time), Some(total_correct))) if total_correct > 0 => {\n                Ok(Some(total_time as f64 / total_correct as f64))\n            }\n            _ => Ok(None),\n        }\n    }\n\n    /// Get miss rate for a character (percentage of incorrect attempts) from aggregated data\n    pub fn get_miss_rate(&self, character: char) -> Result<f64> {\n        let mut stmt = self.conn.prepare(\n            r#\"\n            SELECT \n                SUM(total_attempts) as total,\n                SUM(total_attempts - correct_attempts) as incorrect\n            FROM char_session_stats \n            WHERE character = ?1\n            \"#,\n        )?;\n\n        let result: Result<(Option<i64>, Option<i64>), _> = stmt\n            .query_row([character.to_string()], |row| {\n                Ok((row.get(0)?, row.get(1)?))\n            });\n\n        match result {\n            Ok((Some(total), Some(incorrect))) if total > 0 => {\n                Ok((incorrect as f64 / total as f64) * 100.0)\n            }\n            _ => Ok(0.0),\n        }\n    }\n\n    /// Get all character statistics summary from aggregated session data\n    pub fn get_all_char_summary(&self) -> Result<Vec<(char, f64, f64, i64)>> {\n        let mut stmt = self.conn.prepare(\n            r#\"\n            SELECT \n                character,\n                CASE \n                    WHEN SUM(correct_attempts) > 0 THEN \n                        CAST(SUM(total_time_ms) AS FLOAT) / SUM(correct_attempts)\n                    ELSE 0.0\n                END as avg_time,\n                CASE \n                    WHEN SUM(total_attempts) > 0 THEN \n                        (SUM(total_attempts - correct_attempts) * 100.0 / SUM(total_attempts))\n                    ELSE 0.0\n                END as miss_rate,\n                SUM(total_attempts) as total_attempts\n            FROM char_session_stats \n            GROUP BY character\n            ORDER BY character\n            \"#,\n        )?;\n\n        let summary_iter = stmt.query_map([], |row| {\n            let char_str: String = row.get(0)?;\n            let character = char_str.chars().next().unwrap_or('\\0');\n            let avg_time: f64 = row.get(1)?;\n            let miss_rate: f64 = row.get(2)?;\n            let total_attempts: i64 = row.get(3)?;\n\n            Ok((character, avg_time, miss_rate, total_attempts))\n        })?;\n\n        let mut summary = Vec::new();\n        for item in summary_iter {\n            summary.push(item?);\n        }\n\n        Ok(summary)\n    }\n\n    /// Clear all statistics (for testing or reset purposes)\n    pub fn clear_all_stats(&self) -> Result<()> {\n        self.conn.execute(\"DELETE FROM char_session_stats\", [])?;\n        Ok(())\n    }\n\n    /// Get the actual database file path being used (for debugging)\n    pub fn get_database_path() -> Option<PathBuf> {\n        Self::get_db_path()\n    }\n\n    /// Check if the database file exists on disk\n    pub fn database_exists() -> bool {\n        if let Some(path) = Self::get_db_path() {\n            path.exists()\n        } else {\n            false\n        }\n    }\n\n    /// Get session statistics count\n    pub fn get_session_count(&self) -> Result<i64> {\n        self.conn\n            .query_row(\"SELECT COUNT(*) FROM char_session_stats\", [], |row| {\n                row.get(0)\n            })\n    }\n\n    /// Get character difficulty metrics for intelligent word selection\n    pub fn get_character_difficulties(&self) -> Result<HashMap<char, CharacterDifficulty>> {\n        let mut stmt = self.conn.prepare(\n            r#\"\n            SELECT \n                character,\n                CASE \n                    WHEN SUM(correct_attempts) > 0 THEN \n                        CAST(SUM(total_time_ms) AS FLOAT) / SUM(correct_attempts)\n                    ELSE 500.0\n                END as avg_time,\n                CASE \n                    WHEN SUM(total_attempts) > 0 THEN \n                        (SUM(total_attempts - correct_attempts) * 100.0 / SUM(total_attempts))\n                    ELSE 50.0\n                END as miss_rate,\n                SUM(total_attempts) as total_attempts,\n                CASE \n                    WHEN SUM(uppercase_correct) > 0 THEN \n                        CAST(SUM(uppercase_time_ms) AS FLOAT) / SUM(uppercase_correct)\n                    ELSE 700.0\n                END as uppercase_avg_time,\n                CASE \n                    WHEN SUM(uppercase_attempts) > 0 THEN \n                        (SUM(uppercase_attempts - uppercase_correct) * 100.0 / SUM(uppercase_attempts))\n                    ELSE 75.0\n                END as uppercase_miss_rate,\n                SUM(uppercase_attempts) as uppercase_attempts\n            FROM char_session_stats \n            GROUP BY character\n            HAVING SUM(total_attempts) >= 3  -- Only include characters with sufficient data\n            ORDER BY character\n            \"#,\n        )?;\n\n        let difficulty_iter = stmt.query_map([], |row| {\n            let char_str: String = row.get(0)?;\n            let character = char_str.chars().next().unwrap_or('\\0');\n            let avg_time: f64 = row.get(1)?;\n            let miss_rate: f64 = row.get(2)?;\n            let total_attempts: i64 = row.get(3)?;\n            let uppercase_avg_time: f64 = row.get(4)?;\n            let uppercase_miss_rate: f64 = row.get(5)?;\n            let uppercase_attempts: i64 = row.get(6)?;\n\n            // Calculate uppercase penalty based on performance difference\n            let uppercase_penalty = if uppercase_attempts > 0 {\n                let time_penalty = (uppercase_avg_time - avg_time).max(0.0) / avg_time;\n                let miss_penalty = (uppercase_miss_rate - miss_rate).max(0.0) / 100.0;\n                (time_penalty + miss_penalty).min(1.0) // Cap at 1.0\n            } else {\n                0.5 // Default penalty when no uppercase data\n            };\n\n            Ok((\n                character,\n                CharacterDifficulty {\n                    miss_rate,\n                    avg_time_ms: avg_time,\n                    total_attempts,\n                    uppercase_miss_rate,\n                    uppercase_avg_time,\n                    uppercase_attempts,\n                    uppercase_penalty,\n                },\n            ))\n        })?;\n\n        let mut difficulties = HashMap::new();\n        for item in difficulty_iter {\n            let (character, difficulty) = item?;\n            difficulties.insert(character, difficulty);\n        }\n\n        Ok(difficulties)\n    }\n}\n\n/// Helper function to calculate time difference in milliseconds\npub fn time_diff_ms(start: SystemTime, end: SystemTime) -> u64 {\n    end.duration_since(start).unwrap_or_default().as_millis() as u64\n}\n\n/// Helper function to extract context around a character position\npub fn extract_context(text: &str, position: usize, context_size: usize) -> (String, String) {\n    let chars: Vec<char> = text.chars().collect();\n\n    let before_start = position.saturating_sub(context_size);\n\n    let after_end = std::cmp::min(position + context_size + 1, chars.len());\n\n    let before: String = chars[before_start..position].iter().collect();\n    let after: String = chars[position + 1..after_end].iter().collect();\n\n    (before, after)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn create_test_db() -> StatsDb {\n        // Create an in-memory database for testing\n        let conn = Connection::open_in_memory().unwrap();\n\n        conn.execute(\n            r#\"\n            CREATE TABLE IF NOT EXISTS char_session_stats (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                character TEXT NOT NULL,\n                total_attempts INTEGER NOT NULL,\n                correct_attempts INTEGER NOT NULL,\n                total_time_ms INTEGER NOT NULL,\n                min_time_ms INTEGER NOT NULL,\n                max_time_ms INTEGER NOT NULL,\n                uppercase_attempts INTEGER NOT NULL DEFAULT 0,\n                uppercase_correct INTEGER NOT NULL DEFAULT 0,\n                uppercase_time_ms INTEGER NOT NULL DEFAULT 0,\n                uppercase_min_time INTEGER NOT NULL DEFAULT 0,\n                uppercase_max_time INTEGER NOT NULL DEFAULT 0,\n                session_date TEXT NOT NULL,\n                created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n            )\n            \"#,\n            [],\n        )\n        .unwrap();\n\n        conn.execute(\n            \"CREATE INDEX IF NOT EXISTS idx_char_session_stats_char ON char_session_stats(character)\",\n            [],\n        ).unwrap();\n\n        conn.execute(\n            \"CREATE INDEX IF NOT EXISTS idx_char_session_stats_date ON char_session_stats(session_date)\",\n            [],\n        ).unwrap();\n\n        StatsDb {\n            conn,\n            session_buffer: HashMap::new(),\n        }\n    }\n\n    #[test]\n    fn test_time_diff_ms() {\n        let start = SystemTime::now();\n        std::thread::sleep(std::time::Duration::from_millis(10));\n        let end = SystemTime::now();\n\n        let diff = time_diff_ms(start, end);\n        assert!(diff >= 8); // Allow some timing variance\n        assert!(diff < 100); // More generous upper bound for slower systems\n    }\n\n    #[test]\n    fn test_extract_context() {\n        let text = \"hello world test\";\n        let (before, after) = extract_context(text, 6, 3);\n\n        assert_eq!(before, \"lo \");\n        assert_eq!(after, \"orl\");\n    }\n\n    #[test]\n    fn test_extract_context_at_beginning() {\n        let text = \"hello world\";\n        let (before, after) = extract_context(text, 0, 3);\n\n        assert_eq!(before, \"\");\n        assert_eq!(after, \"ell\");\n    }\n\n    #[test]\n    fn test_extract_context_at_end() {\n        let text = \"hello world\";\n        let (before, after) = extract_context(text, 10, 3);\n\n        assert_eq!(before, \"orl\");\n        assert_eq!(after, \"\");\n    }\n\n    #[test]\n    fn test_record_and_retrieve_aggregated_stats() {\n        let mut db = create_test_db();\n\n        let stats = vec![\n            CharStat {\n                character: 'h',\n                time_to_press_ms: 150,\n                was_correct: true,\n                was_uppercase: false,\n                timestamp: Local::now(),\n                context_before: \"\".to_string(),\n                context_after: \"ello\".to_string(),\n            },\n            CharStat {\n                character: 'h',\n                time_to_press_ms: 120,\n                was_correct: true,\n                was_uppercase: false,\n                timestamp: Local::now(),\n                context_before: \"\".to_string(),\n                context_after: \"ello\".to_string(),\n            },\n        ];\n\n        db.record_char_stats_batch(&stats).unwrap();\n\n        let avg = db.get_avg_time_to_press('h').unwrap();\n        assert_eq!(avg, Some(135.0)); // (150 + 120) / 2\n    }\n\n    #[test]\n    fn test_session_aggregation() {\n        let mut db = create_test_db();\n\n        let stats = vec![\n            CharStat {\n                character: 't',\n                time_to_press_ms: 100,\n                was_correct: true,\n                was_uppercase: false,\n                timestamp: Local::now(),\n                context_before: \"\".to_string(),\n                context_after: \"est\".to_string(),\n            },\n            CharStat {\n                character: 't',\n                time_to_press_ms: 150,\n                was_correct: false,\n                was_uppercase: false,\n                timestamp: Local::now(),\n                context_before: \"\".to_string(),\n                context_after: \"est\".to_string(),\n            },\n            CharStat {\n                character: 't',\n                time_to_press_ms: 120,\n                was_correct: true,\n                was_uppercase: false,\n                timestamp: Local::now(),\n                context_before: \"\".to_string(),\n                context_after: \"est\".to_string(),\n            },\n        ];\n\n        db.record_char_stats_batch(&stats).unwrap();\n\n        let miss_rate = db.get_miss_rate('t').unwrap();\n        assert!((miss_rate - 33.33).abs() < 0.1); // 1 out of 3 = 33.33%\n\n        let avg_time = db.get_avg_time_to_press('t').unwrap();\n        assert_eq!(avg_time, Some(110.0)); // (100 + 120) / 2 (only correct attempts)\n    }\n\n    #[test]\n    fn test_clear_all_stats() {\n        let mut db = create_test_db();\n\n        let stat = CharStat {\n            character: 'x',\n            time_to_press_ms: 100,\n            was_correct: true,\n            was_uppercase: false,\n            timestamp: Local::now(),\n            context_before: \"\".to_string(),\n            context_after: \"yz\".to_string(),\n        };\n\n        db.record_char_stats_batch(&[stat]).unwrap();\n        let summary_before = db.get_all_char_summary().unwrap();\n        assert_eq!(summary_before.len(), 1);\n\n        db.clear_all_stats().unwrap();\n        let summary_after = db.get_all_char_summary().unwrap();\n        assert_eq!(summary_after.len(), 0);\n    }\n\n    #[test]\n    fn test_flush() {\n        let mut db = create_test_db();\n\n        let stat = CharStat {\n            character: 'f',\n            time_to_press_ms: 120,\n            was_correct: true,\n            was_uppercase: false,\n            timestamp: Local::now(),\n            context_before: \"\".to_string(),\n            context_after: \"oo\".to_string(),\n        };\n\n        db.record_char_stat(&stat).unwrap();\n\n        // Before flush, no stats in database\n        let summary_before = db.get_all_char_summary().unwrap();\n        assert_eq!(summary_before.len(), 0);\n\n        db.flush().unwrap();\n\n        // After flush, stats are in database\n        let summary_after = db.get_all_char_summary().unwrap();\n        assert_eq!(summary_after.len(), 1);\n        assert_eq!(summary_after[0].0, 'f');\n    }\n\n    #[test]\n    fn test_session_count() {\n        let db = create_test_db();\n        let session_count = db.get_session_count().unwrap();\n\n        // New database should have no entries\n        assert_eq!(session_count, 0);\n    }\n}\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":63}},{"line":49,"address":[],"length":0,"stats":{"Line":126}},{"line":52,"address":[],"length":0,"stats":{"Line":126}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":126}},{"line":87,"address":[],"length":0,"stats":{"Line":63}},{"line":92,"address":[],"length":0,"stats":{"Line":63}},{"line":97,"address":[],"length":0,"stats":{"Line":63}},{"line":98,"address":[],"length":0,"stats":{"Line":63}},{"line":99,"address":[],"length":0,"stats":{"Line":63}},{"line":104,"address":[],"length":0,"stats":{"Line":64}},{"line":106,"address":[],"length":0,"stats":{"Line":128}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":48}},{"line":123,"address":[],"length":0,"stats":{"Line":48}},{"line":124,"address":[],"length":0,"stats":{"Line":48}},{"line":126,"address":[],"length":0,"stats":{"Line":48}},{"line":127,"address":[],"length":0,"stats":{"Line":48}},{"line":131,"address":[],"length":0,"stats":{"Line":9}},{"line":132,"address":[],"length":0,"stats":{"Line":9}},{"line":134,"address":[],"length":0,"stats":{"Line":51}},{"line":135,"address":[],"length":0,"stats":{"Line":21}},{"line":142,"address":[],"length":0,"stats":{"Line":21}},{"line":143,"address":[],"length":0,"stats":{"Line":21}},{"line":144,"address":[],"length":0,"stats":{"Line":21}},{"line":145,"address":[],"length":0,"stats":{"Line":21}},{"line":146,"address":[],"length":0,"stats":{"Line":21}},{"line":147,"address":[],"length":0,"stats":{"Line":21}},{"line":148,"address":[],"length":0,"stats":{"Line":21}},{"line":149,"address":[],"length":0,"stats":{"Line":21}},{"line":150,"address":[],"length":0,"stats":{"Line":21}},{"line":151,"address":[],"length":0,"stats":{"Line":21}},{"line":152,"address":[],"length":0,"stats":{"Line":21}},{"line":153,"address":[],"length":0,"stats":{"Line":21}},{"line":154,"address":[],"length":0,"stats":{"Line":21}},{"line":159,"address":[],"length":0,"stats":{"Line":9}},{"line":163,"address":[],"length":0,"stats":{"Line":11}},{"line":164,"address":[],"length":0,"stats":{"Line":11}},{"line":165,"address":[],"length":0,"stats":{"Line":2}},{"line":169,"address":[],"length":0,"stats":{"Line":9}},{"line":172,"address":[],"length":0,"stats":{"Line":9}},{"line":175,"address":[],"length":0,"stats":{"Line":9}},{"line":177,"address":[],"length":0,"stats":{"Line":9}},{"line":181,"address":[],"length":0,"stats":{"Line":3}},{"line":183,"address":[],"length":0,"stats":{"Line":15}},{"line":184,"address":[],"length":0,"stats":{"Line":6}},{"line":188,"address":[],"length":0,"stats":{"Line":3}},{"line":192,"address":[],"length":0,"stats":{"Line":9}},{"line":195,"address":[],"length":0,"stats":{"Line":9}},{"line":197,"address":[],"length":0,"stats":{"Line":51}},{"line":212,"address":[],"length":0,"stats":{"Line":79}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":27}},{"line":221,"address":[],"length":0,"stats":{"Line":27}},{"line":222,"address":[],"length":0,"stats":{"Line":27}},{"line":223,"address":[],"length":0,"stats":{"Line":27}},{"line":225,"address":[],"length":0,"stats":{"Line":27}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":1}},{"line":238,"address":[],"length":0,"stats":{"Line":1}},{"line":240,"address":[],"length":0,"stats":{"Line":21}},{"line":241,"address":[],"length":0,"stats":{"Line":21}},{"line":247,"address":[],"length":0,"stats":{"Line":9}},{"line":251,"address":[],"length":0,"stats":{"Line":3}},{"line":254,"address":[],"length":0,"stats":{"Line":3}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":4}},{"line":295,"address":[],"length":0,"stats":{"Line":8}},{"line":304,"address":[],"length":0,"stats":{"Line":4}},{"line":305,"address":[],"length":0,"stats":{"Line":8}},{"line":308,"address":[],"length":0,"stats":{"Line":4}},{"line":309,"address":[],"length":0,"stats":{"Line":12}},{"line":310,"address":[],"length":0,"stats":{"Line":4}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":3}},{"line":318,"address":[],"length":0,"stats":{"Line":6}},{"line":329,"address":[],"length":0,"stats":{"Line":3}},{"line":330,"address":[],"length":0,"stats":{"Line":6}},{"line":333,"address":[],"length":0,"stats":{"Line":3}},{"line":334,"address":[],"length":0,"stats":{"Line":9}},{"line":335,"address":[],"length":0,"stats":{"Line":3}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":7}},{"line":343,"address":[],"length":0,"stats":{"Line":14}},{"line":364,"address":[],"length":0,"stats":{"Line":102}},{"line":365,"address":[],"length":0,"stats":{"Line":190}},{"line":367,"address":[],"length":0,"stats":{"Line":95}},{"line":368,"address":[],"length":0,"stats":{"Line":95}},{"line":369,"address":[],"length":0,"stats":{"Line":95}},{"line":375,"address":[],"length":0,"stats":{"Line":197}},{"line":376,"address":[],"length":0,"stats":{"Line":95}},{"line":379,"address":[],"length":0,"stats":{"Line":7}},{"line":383,"address":[],"length":0,"stats":{"Line":1}},{"line":384,"address":[],"length":0,"stats":{"Line":1}},{"line":385,"address":[],"length":0,"stats":{"Line":1}},{"line":389,"address":[],"length":0,"stats":{"Line":1}},{"line":390,"address":[],"length":0,"stats":{"Line":1}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":1}},{"line":404,"address":[],"length":0,"stats":{"Line":1}},{"line":405,"address":[],"length":0,"stats":{"Line":2}},{"line":406,"address":[],"length":0,"stats":{"Line":1}},{"line":411,"address":[],"length":0,"stats":{"Line":15}},{"line":412,"address":[],"length":0,"stats":{"Line":30}},{"line":445,"address":[],"length":0,"stats":{"Line":300}},{"line":446,"address":[],"length":0,"stats":{"Line":570}},{"line":448,"address":[],"length":0,"stats":{"Line":285}},{"line":449,"address":[],"length":0,"stats":{"Line":285}},{"line":450,"address":[],"length":0,"stats":{"Line":285}},{"line":451,"address":[],"length":0,"stats":{"Line":285}},{"line":452,"address":[],"length":0,"stats":{"Line":285}},{"line":453,"address":[],"length":0,"stats":{"Line":285}},{"line":457,"address":[],"length":0,"stats":{"Line":120}},{"line":458,"address":[],"length":0,"stats":{"Line":120}},{"line":459,"address":[],"length":0,"stats":{"Line":120}},{"line":461,"address":[],"length":0,"stats":{"Line":165}},{"line":479,"address":[],"length":0,"stats":{"Line":585}},{"line":480,"address":[],"length":0,"stats":{"Line":570}},{"line":484,"address":[],"length":0,"stats":{"Line":15}},{"line":489,"address":[],"length":0,"stats":{"Line":8}},{"line":490,"address":[],"length":0,"stats":{"Line":8}},{"line":494,"address":[],"length":0,"stats":{"Line":44}},{"line":495,"address":[],"length":0,"stats":{"Line":44}},{"line":497,"address":[],"length":0,"stats":{"Line":44}},{"line":499,"address":[],"length":0,"stats":{"Line":44}},{"line":501,"address":[],"length":0,"stats":{"Line":44}},{"line":502,"address":[],"length":0,"stats":{"Line":44}},{"line":504,"address":[],"length":0,"stats":{"Line":44}}],"covered":120,"coverable":159},{"path":["/","Users","martintrojer","hacking","thokr","src","thok.rs"],"content":"use crate::stats::{extract_context, time_diff_ms, CharStat, StatsDb};\nuse crate::util::std_dev;\nuse crate::TICK_RATE_MS;\nuse chrono::prelude::*;\nuse directories::ProjectDirs;\nuse itertools::Itertools;\nuse std::fs::OpenOptions;\nuse std::io::{self, Write};\nuse std::{\n    char,\n    collections::{HashMap, HashSet},\n    time::SystemTime,\n};\n\n#[derive(Clone, Debug, Copy, PartialEq)]\npub enum Outcome {\n    Correct,\n    Incorrect,\n}\n\n#[derive(Clone, Copy, Debug, PartialEq)]\npub struct Input {\n    pub char: char,\n    pub outcome: Outcome,\n    pub timestamp: SystemTime,\n    pub keypress_start: Option<SystemTime>,\n}\n\n/// represents a test being displayed to the user\n#[derive(Debug)]\npub struct Thok {\n    pub prompt: String,\n    pub input: Vec<Input>,\n    pub raw_coords: Vec<(f64, f64)>,\n    pub wpm_coords: Vec<(f64, f64)>,\n    pub cursor_pos: usize,\n    pub started_at: Option<SystemTime>,\n    pub seconds_remaining: Option<f64>,\n    pub number_of_secs: Option<f64>,\n    pub number_of_words: usize,\n    pub wpm: f64,\n    pub accuracy: f64,\n    pub std_dev: f64,\n    pub stats_db: Option<StatsDb>,\n    pub keypress_start_time: Option<SystemTime>,\n    pub strict_mode: bool,\n    pub corrected_positions: std::collections::HashSet<usize>, // Track positions that had errors\n}\n\nimpl Thok {\n    pub fn new(\n        prompt: String,\n        number_of_words: usize,\n        number_of_secs: Option<f64>,\n        strict_mode: bool,\n    ) -> Self {\n        let stats_db = StatsDb::new().ok();\n        Self {\n            prompt,\n            input: vec![],\n            raw_coords: vec![],\n            wpm_coords: vec![],\n            cursor_pos: 0,\n            started_at: None,\n            number_of_secs,\n            number_of_words,\n            seconds_remaining: number_of_secs,\n            wpm: 0.0,\n            accuracy: 0.0,\n            std_dev: 0.0,\n            stats_db,\n            keypress_start_time: None,\n            strict_mode,\n            corrected_positions: HashSet::new(),\n        }\n    }\n\n    pub fn on_tick(&mut self) {\n        self.seconds_remaining =\n            Some(self.seconds_remaining.unwrap() - (TICK_RATE_MS as f64 / 1000_f64));\n    }\n\n    pub fn get_expected_char(&self, idx: usize) -> char {\n        self.prompt.chars().nth(idx).unwrap()\n    }\n\n    pub fn increment_cursor(&mut self) {\n        if self.cursor_pos < self.input.len() {\n            self.cursor_pos += 1;\n        }\n    }\n\n    pub fn decrement_cursor(&mut self) {\n        if self.cursor_pos > 0 {\n            self.cursor_pos -= 1;\n        }\n    }\n\n    pub fn calc_results(&mut self) {\n        let correct_chars = self\n            .input\n            .clone()\n            .into_iter()\n            .filter(|i| i.outcome == Outcome::Correct)\n            .collect::<Vec<Input>>();\n\n        let elapsed_secs = self.started_at.unwrap().elapsed().unwrap().as_millis() as f64;\n\n        let whole_second_limit = elapsed_secs.floor();\n\n        let correct_chars_per_sec: Vec<(f64, f64)> = correct_chars\n            .clone()\n            .into_iter()\n            .fold(HashMap::new(), |mut map, i| {\n                let mut num_secs = i\n                    .timestamp\n                    .duration_since(self.started_at.unwrap())\n                    .unwrap()\n                    .as_secs_f64();\n\n                if num_secs == 0.0 {\n                    num_secs = 1.;\n                } else if num_secs.ceil() <= whole_second_limit {\n                    if num_secs > 0. && num_secs < 1. {\n                        // this accounts for the initiated keypress at 0.000\n                        num_secs = 1.;\n                    } else {\n                        num_secs = num_secs.ceil()\n                    }\n                } else {\n                    num_secs = elapsed_secs;\n                }\n\n                *map.entry(num_secs.to_string()).or_insert(0) += 1;\n                map\n            })\n            .into_iter()\n            .map(|(k, v)| (k.parse::<f64>().unwrap(), v as f64))\n            .sorted_by(|a, b| a.partial_cmp(b).unwrap())\n            .collect();\n\n        let correct_chars_at_whole_sec_intervals = correct_chars_per_sec\n            .iter()\n            .enumerate()\n            .filter(|&(i, _)| i < correct_chars_per_sec.len() - 1)\n            .map(|(_, x)| x.1)\n            .collect::<Vec<f64>>();\n\n        if !correct_chars_at_whole_sec_intervals.is_empty() {\n            self.std_dev = std_dev(&correct_chars_at_whole_sec_intervals).unwrap();\n        } else {\n            self.std_dev = 0.0;\n        }\n\n        let mut correct_chars_pressed_until_now = 0.0;\n\n        for x in correct_chars_per_sec {\n            correct_chars_pressed_until_now += x.1;\n            self.wpm_coords\n                .push((x.0, ((60.00 / x.0) * correct_chars_pressed_until_now) / 5.0))\n        }\n\n        if !self.wpm_coords.is_empty() {\n            self.wpm = self.wpm_coords.last().unwrap().1.ceil();\n        } else {\n            self.wpm = 0.0;\n        }\n        self.accuracy = ((correct_chars.len() as f64 / self.input.len() as f64) * 100.0).round();\n\n        let _ = self.save_results();\n\n        // Flush character statistics to database\n        if self.flush_char_stats().is_some() {\n            // For debugging: uncomment to see when stats are flushed\n            // eprintln!(\"Character statistics flushed to database\");\n        };\n    }\n\n    pub fn backspace(&mut self) {\n        if self.strict_mode {\n            // In strict mode, backspace should reset the current position to allow retry\n            if self.cursor_pos > 0 {\n                self.decrement_cursor();\n                // Remove the input at the new cursor position if it exists\n                if self.cursor_pos < self.input.len() {\n                    self.input.remove(self.cursor_pos);\n                }\n            }\n        } else {\n            // Normal mode: remove previous character and move cursor back\n            if self.cursor_pos > 0 {\n                self.input.remove(self.cursor_pos - 1);\n                self.decrement_cursor();\n            }\n        }\n    }\n\n    pub fn start(&mut self) {\n        self.started_at = Some(SystemTime::now());\n    }\n\n    pub fn on_keypress_start(&mut self) {\n        self.keypress_start_time = Some(SystemTime::now());\n    }\n\n    pub fn write(&mut self, c: char) {\n        let idx = if self.strict_mode {\n            // In strict mode, use cursor position instead of input length\n            self.cursor_pos\n        } else {\n            self.input.len()\n        };\n\n        if idx == 0 && self.started_at.is_none() {\n            self.start();\n        }\n\n        let now = SystemTime::now();\n        let expected_char = self.get_expected_char(idx);\n        let outcome = if c == expected_char {\n            Outcome::Correct\n        } else {\n            Outcome::Incorrect\n        };\n\n        // Calculate time to press if we have a start time\n        let time_to_press_ms = if let Some(start_time) = self.keypress_start_time {\n            time_diff_ms(start_time, now)\n        } else {\n            0\n        };\n\n        // Record character statistics if database is available\n        if let Some(ref mut stats_db) = self.stats_db {\n            let (context_before, context_after) = extract_context(&self.prompt, idx, 3);\n\n            let char_stat = CharStat {\n                character: expected_char.to_lowercase().next().unwrap_or(expected_char), // Store as lowercase\n                time_to_press_ms,\n                was_correct: outcome == Outcome::Correct,\n                was_uppercase: expected_char.is_uppercase(),\n                timestamp: Local::now(),\n                context_before,\n                context_after,\n            };\n\n            // Record character statistic (failures are silently ignored to not interrupt typing)\n            if let Err(_e) = stats_db.record_char_stat(&char_stat) {\n                // For debugging: uncomment the line below to see database errors\n                // eprintln!(\"Warning: Failed to record character stat: {}\", e);\n            } else {\n                // For debugging: uncomment the line below to see successful recordings\n                // eprintln!(\"Recorded stat for '{}': {}ms\", expected_char, time_to_press_ms);\n            }\n        }\n\n        if self.strict_mode {\n            // In strict mode, handle cursor progression differently\n            if outcome == Outcome::Correct {\n                // Check if this position had previous errors\n                let had_error = self.cursor_pos < self.input.len()\n                    && self.input[self.cursor_pos].outcome == Outcome::Incorrect;\n\n                // If there was a previous error, mark this position as corrected\n                if had_error {\n                    self.corrected_positions.insert(self.cursor_pos);\n                }\n\n                // Replace any existing input at this position with the correct one\n                if self.cursor_pos < self.input.len() {\n                    self.input[self.cursor_pos] = Input {\n                        char: c,\n                        outcome,\n                        timestamp: now,\n                        keypress_start: self.keypress_start_time,\n                    };\n                } else {\n                    // Add new input if we're at the end\n                    self.input.push(Input {\n                        char: c,\n                        outcome,\n                        timestamp: now,\n                        keypress_start: self.keypress_start_time,\n                    });\n                }\n                // Only advance cursor on correct input\n                self.increment_cursor();\n            } else {\n                // For incorrect input, update the input at current position but don't advance cursor\n                if self.cursor_pos < self.input.len() {\n                    self.input[self.cursor_pos] = Input {\n                        char: c,\n                        outcome,\n                        timestamp: now,\n                        keypress_start: self.keypress_start_time,\n                    };\n                } else {\n                    // Add new input if we're at the end\n                    self.input.push(Input {\n                        char: c,\n                        outcome,\n                        timestamp: now,\n                        keypress_start: self.keypress_start_time,\n                    });\n                }\n                // Cursor stays at the same position for retry\n            }\n        } else {\n            // Normal mode: always insert and advance\n            self.input.insert(\n                self.cursor_pos,\n                Input {\n                    char: c,\n                    outcome,\n                    timestamp: now,\n                    keypress_start: self.keypress_start_time,\n                },\n            );\n            self.increment_cursor();\n        }\n\n        // Reset keypress start time for next character\n        self.keypress_start_time = None;\n    }\n\n    pub fn has_started(&self) -> bool {\n        self.started_at.is_some()\n    }\n\n    pub fn has_finished(&self) -> bool {\n        (self.input.len() == self.prompt.len())\n            || (self.seconds_remaining.is_some() && self.seconds_remaining.unwrap() <= 0.0)\n    }\n\n    pub fn save_results(&self) -> io::Result<()> {\n        if let Some(proj_dirs) = ProjectDirs::from(\"\", \"\", \"thokr\") {\n            let config_dir = proj_dirs.config_dir();\n            let log_path = config_dir.join(\"log.csv\");\n\n            std::fs::create_dir_all(config_dir)?;\n\n            // If the config file doesn't exist, we need to emit a header\n            let needs_header = !log_path.exists();\n\n            let mut log_file = OpenOptions::new()\n                .append(true)\n                .create(true)\n                .open(log_path)?;\n\n            if needs_header {\n                writeln!(\n                    log_file,\n                    \"date,num_words,num_secs,elapsed_secs,wpm,accuracy,std_dev\"\n                )?;\n            }\n\n            let elapsed_secs = self.started_at.unwrap().elapsed().unwrap().as_secs_f64();\n\n            writeln!(\n                log_file,\n                \"{},{},{},{:.2},{},{},{:.2}\",\n                Local::now().format(\"%c\"),\n                self.number_of_words,\n                self.number_of_secs\n                    .map_or(String::from(\"\"), |ns| format!(\"{:.2}\", ns)),\n                elapsed_secs,\n                self.wpm,      // already rounded, no need to round to two decimal places\n                self.accuracy, // already rounded, no need to round to two decimal places\n                self.std_dev,\n            )?;\n        }\n\n        Ok(())\n    }\n\n    /// Get character statistics for analysis\n    pub fn get_char_stats(&self, character: char) -> Option<Vec<crate::stats::CharStat>> {\n        if let Some(ref stats_db) = self.stats_db {\n            stats_db.get_char_stats(character).ok()\n        } else {\n            None\n        }\n    }\n\n    /// Get average time to press for a character\n    pub fn get_avg_time_to_press(&self, character: char) -> Option<f64> {\n        if let Some(ref stats_db) = self.stats_db {\n            stats_db.get_avg_time_to_press(character).ok().flatten()\n        } else {\n            None\n        }\n    }\n\n    /// Get miss rate for a character\n    pub fn get_miss_rate(&self, character: char) -> Option<f64> {\n        if let Some(ref stats_db) = self.stats_db {\n            stats_db.get_miss_rate(character).ok()\n        } else {\n            None\n        }\n    }\n\n    /// Get summary of all character statistics\n    pub fn get_all_char_summary(&self) -> Option<Vec<(char, f64, f64, i64)>> {\n        if let Some(ref stats_db) = self.stats_db {\n            stats_db.get_all_char_summary().ok()\n        } else {\n            None\n        }\n    }\n\n    /// Flush character statistics to ensure all data is written to database\n    pub fn flush_char_stats(&mut self) -> Option<()> {\n        if let Some(ref mut stats_db) = self.stats_db {\n            stats_db.flush().ok()\n        } else {\n            None\n        }\n    }\n\n    /// Check if character statistics database is available\n    pub fn has_stats_database(&self) -> bool {\n        self.stats_db.is_some()\n    }\n\n    /// Get the database path being used (for debugging)\n    pub fn get_stats_database_path(&self) -> Option<std::path::PathBuf> {\n        crate::stats::StatsDb::get_database_path()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::time::Duration;\n\n    #[test]\n    fn test_outcome_equality() {\n        assert_eq!(Outcome::Correct, Outcome::Correct);\n        assert_eq!(Outcome::Incorrect, Outcome::Incorrect);\n        assert_ne!(Outcome::Correct, Outcome::Incorrect);\n    }\n\n    #[test]\n    fn test_input_creation() {\n        let timestamp = SystemTime::now();\n        let input = Input {\n            char: 'a',\n            outcome: Outcome::Correct,\n            timestamp,\n            keypress_start: None,\n        };\n\n        assert_eq!(input.char, 'a');\n        assert_eq!(input.outcome, Outcome::Correct);\n        assert_eq!(input.timestamp, timestamp);\n        assert_eq!(input.keypress_start, None);\n    }\n\n    #[test]\n    fn test_thok_new() {\n        let thok = Thok::new(\"hello world\".to_string(), 2, None, false);\n\n        assert_eq!(thok.prompt, \"hello world\");\n        assert_eq!(thok.number_of_words, 2);\n        assert_eq!(thok.number_of_secs, None);\n        assert_eq!(thok.input.len(), 0);\n        assert_eq!(thok.cursor_pos, 0);\n        assert_eq!(thok.wpm, 0.0);\n        assert_eq!(thok.accuracy, 0.0);\n        assert_eq!(thok.std_dev, 0.0);\n        assert!(!thok.has_started());\n        assert!(!thok.has_finished());\n        assert!(!thok.strict_mode);\n    }\n\n    #[test]\n    fn test_thok_new_with_time_limit() {\n        let thok = Thok::new(\"test\".to_string(), 1, Some(30.0), false);\n\n        assert_eq!(thok.number_of_secs, Some(30.0));\n        assert_eq!(thok.seconds_remaining, Some(30.0));\n    }\n\n    #[test]\n    fn test_get_expected_char() {\n        let thok = Thok::new(\"hello\".to_string(), 1, None, false);\n\n        assert_eq!(thok.get_expected_char(0), 'h');\n        assert_eq!(thok.get_expected_char(1), 'e');\n        assert_eq!(thok.get_expected_char(4), 'o');\n    }\n\n    #[test]\n    fn test_write_correct_char() {\n        let mut thok = Thok::new(\"test\".to_string(), 1, None, false);\n\n        thok.write('t');\n\n        assert_eq!(thok.input.len(), 1);\n        assert_eq!(thok.input[0].char, 't');\n        assert_eq!(thok.input[0].outcome, Outcome::Correct);\n        assert_eq!(thok.cursor_pos, 1);\n        assert!(thok.has_started());\n    }\n\n    #[test]\n    fn test_write_incorrect_char() {\n        let mut thok = Thok::new(\"test\".to_string(), 1, None, false);\n\n        thok.write('x');\n\n        assert_eq!(thok.input.len(), 1);\n        assert_eq!(thok.input[0].char, 'x');\n        assert_eq!(thok.input[0].outcome, Outcome::Incorrect);\n        assert_eq!(thok.cursor_pos, 1);\n    }\n\n    #[test]\n    fn test_backspace() {\n        let mut thok = Thok::new(\"test\".to_string(), 1, None, false);\n\n        thok.write('t');\n        thok.write('e');\n        assert_eq!(thok.input.len(), 2);\n        assert_eq!(thok.cursor_pos, 2);\n\n        thok.backspace();\n        assert_eq!(thok.input.len(), 1);\n        assert_eq!(thok.cursor_pos, 1);\n\n        thok.backspace();\n        assert_eq!(thok.input.len(), 0);\n        assert_eq!(thok.cursor_pos, 0);\n    }\n\n    #[test]\n    fn test_backspace_at_start() {\n        let mut thok = Thok::new(\"test\".to_string(), 1, None, false);\n\n        thok.backspace();\n        assert_eq!(thok.input.len(), 0);\n        assert_eq!(thok.cursor_pos, 0);\n    }\n\n    #[test]\n    fn test_increment_cursor() {\n        let mut thok = Thok::new(\"test\".to_string(), 1, None, false);\n        thok.write('t');\n\n        let initial_pos = thok.cursor_pos;\n        thok.increment_cursor();\n\n        assert_eq!(thok.cursor_pos, initial_pos);\n    }\n\n    #[test]\n    fn test_decrement_cursor() {\n        let mut thok = Thok::new(\"test\".to_string(), 1, None, false);\n        thok.write('t');\n\n        let initial_pos = thok.cursor_pos;\n        thok.decrement_cursor();\n\n        assert_eq!(thok.cursor_pos, initial_pos - 1);\n    }\n\n    #[test]\n    fn test_has_finished_by_completion() {\n        let mut thok = Thok::new(\"hi\".to_string(), 1, None, false);\n\n        assert!(!thok.has_finished());\n\n        thok.write('h');\n        assert!(!thok.has_finished());\n\n        thok.write('i');\n        assert!(thok.has_finished());\n    }\n\n    #[test]\n    fn test_has_finished_by_time() {\n        let mut thok = Thok::new(\"test\".to_string(), 1, Some(1.0), false);\n\n        assert!(!thok.has_finished());\n\n        thok.seconds_remaining = Some(0.0);\n        assert!(thok.has_finished());\n\n        thok.seconds_remaining = Some(-1.0);\n        assert!(thok.has_finished());\n    }\n\n    #[test]\n    fn test_on_tick() {\n        let mut thok = Thok::new(\"test\".to_string(), 1, Some(10.0), false);\n        let initial_time = thok.seconds_remaining.unwrap();\n\n        thok.on_tick();\n\n        let expected_time = initial_time - (TICK_RATE_MS as f64 / 1000.0);\n        assert_eq!(thok.seconds_remaining.unwrap(), expected_time);\n    }\n\n    #[test]\n    fn test_calc_results_basic() {\n        let mut thok = Thok::new(\"test\".to_string(), 1, None, false);\n        thok.start();\n\n        thread::sleep(Duration::from_millis(100));\n\n        thok.write('t');\n        thok.write('e');\n        thok.write('s');\n        thok.write('t');\n\n        thok.calc_results();\n\n        assert_eq!(thok.accuracy, 100.0);\n        assert!(thok.wpm > 0.0);\n    }\n\n    #[test]\n    fn test_calc_results_with_errors() {\n        let mut thok = Thok::new(\"test\".to_string(), 1, None, false);\n        thok.start();\n\n        thread::sleep(Duration::from_millis(100));\n\n        thok.write('t');\n        thok.write('x');\n        thok.write('s');\n        thok.write('t');\n\n        thok.calc_results();\n\n        assert_eq!(thok.accuracy, 75.0);\n        assert!(thok.wpm >= 0.0);\n    }\n\n    #[test]\n    fn test_calc_results_empty_input() {\n        let mut thok = Thok::new(\"test\".to_string(), 1, None, false);\n        thok.start();\n\n        thok.calc_results();\n\n        assert_eq!(thok.wpm, 0.0);\n        assert_eq!(thok.std_dev, 0.0);\n    }\n\n    use std::thread;\n\n    #[test]\n    fn test_keypress_timing() {\n        let mut thok = Thok::new(\"test\".to_string(), 1, None, false);\n\n        thok.on_keypress_start();\n        thread::sleep(Duration::from_millis(10));\n        thok.write('t');\n\n        assert_eq!(thok.input.len(), 1);\n        assert_eq!(thok.input[0].char, 't');\n        assert_eq!(thok.input[0].outcome, Outcome::Correct);\n        assert!(thok.input[0].keypress_start.is_some());\n    }\n\n    #[test]\n    fn test_character_statistics_methods() {\n        let thok = Thok::new(\"test\".to_string(), 1, None, false);\n\n        // These methods should return None if no database is available\n        assert!(thok.get_char_stats('t').is_none() || thok.get_char_stats('t').is_some());\n        assert!(\n            thok.get_avg_time_to_press('t').is_none() || thok.get_avg_time_to_press('t').is_some()\n        );\n        assert!(thok.get_miss_rate('t').is_none() || thok.get_miss_rate('t').is_some());\n        assert!(thok.get_all_char_summary().is_none() || thok.get_all_char_summary().is_some());\n    }\n\n    #[test]\n    fn test_keypress_timing_reset() {\n        let mut thok = Thok::new(\"test\".to_string(), 1, None, false);\n\n        thok.on_keypress_start();\n        assert!(thok.keypress_start_time.is_some());\n\n        thok.write('t');\n        assert!(thok.keypress_start_time.is_none()); // Should be reset after write\n    }\n\n    #[test]\n    fn test_flush_char_stats() {\n        let mut thok = Thok::new(\"test\".to_string(), 1, None, false);\n\n        // Flush should work whether or not database is available\n        let result = thok.flush_char_stats();\n        // Result can be Some(()) or None depending on database availability\n        assert!(result.is_some() || result.is_none());\n    }\n\n    #[test]\n    fn test_calc_results_flushes_stats() {\n        let mut thok = Thok::new(\"test\".to_string(), 1, None, false);\n        thok.start();\n\n        thread::sleep(Duration::from_millis(10));\n\n        thok.write('t');\n        thok.write('e');\n        thok.write('s');\n        thok.write('t');\n\n        // This should complete without error and flush stats\n        thok.calc_results();\n\n        assert_eq!(thok.accuracy, 100.0);\n        assert!(thok.wpm > 0.0);\n    }\n\n    #[test]\n    fn test_database_path_and_creation() {\n        let thok = Thok::new(\"test\".to_string(), 1, None, false);\n\n        // Print debug information\n        println!(\"Has stats database: {}\", thok.has_stats_database());\n        if let Some(path) = thok.get_stats_database_path() {\n            println!(\"Database path: {:?}\", path);\n            println!(\"Database exists: {}\", path.exists());\n            if let Some(parent) = path.parent() {\n                println!(\"Parent directory exists: {}\", parent.exists());\n            }\n        }\n\n        // Try to create a character stat\n        if thok.has_stats_database() {\n            println!(\" Database is available for statistics\");\n        } else {\n            println!(\" Database is NOT available for statistics\");\n        }\n    }\n\n    #[test]\n    fn test_real_typing_saves_to_database() {\n        let mut thok = Thok::new(\"hello\".to_string(), 1, None, false);\n\n        println!(\"Starting real typing simulation...\");\n\n        // Simulate real typing with timing\n        thok.on_keypress_start();\n        thread::sleep(Duration::from_millis(100));\n        thok.write('h');\n\n        thok.on_keypress_start();\n        thread::sleep(Duration::from_millis(150));\n        thok.write('e');\n\n        thok.on_keypress_start();\n        thread::sleep(Duration::from_millis(120));\n        thok.write('l');\n\n        thok.on_keypress_start();\n        thread::sleep(Duration::from_millis(90));\n        thok.write('l');\n\n        thok.on_keypress_start();\n        thread::sleep(Duration::from_millis(110));\n        thok.write('o');\n\n        // Complete the typing test\n        assert!(thok.has_finished());\n        thok.calc_results();\n\n        // Now check if we can query the statistics\n        if let Some(h_stats) = thok.get_char_stats('h') {\n            println!(\"Found {} statistics for 'h'\", h_stats.len());\n            if !h_stats.is_empty() {\n                println!(\n                    \"First 'h' stat: char={}, time={}ms, correct={}\",\n                    h_stats[0].character, h_stats[0].time_to_press_ms, h_stats[0].was_correct\n                );\n            }\n        } else {\n            println!(\" No statistics found for 'h'\");\n        }\n\n        if let Some(summary) = thok.get_all_char_summary() {\n            println!(\"Summary statistics for {} characters\", summary.len());\n            for (char, avg_time, miss_rate, attempts) in summary {\n                println!(\n                    \"  '{}': avg={}ms, miss={}%, attempts={}\",\n                    char, avg_time, miss_rate, attempts\n                );\n            }\n        } else {\n            println!(\" No summary statistics found\");\n        }\n    }\n\n    #[test]\n    fn test_strict_mode_cursor_behavior() {\n        let mut thok = Thok::new(\"test\".to_string(), 1, None, true);\n\n        // Test correct input advances cursor\n        thok.write('t');\n        assert_eq!(thok.cursor_pos, 1);\n\n        // Test incorrect input doesn't advance cursor\n        thok.write('x'); // Wrong character for 'e'\n        assert_eq!(thok.cursor_pos, 1); // Cursor should stay at position 1\n        assert_eq!(thok.input[1].outcome, Outcome::Incorrect);\n\n        // Test correct input after error advances cursor and marks as corrected\n        thok.write('e'); // Correct character\n        assert_eq!(thok.cursor_pos, 2); // Cursor should advance\n        assert_eq!(thok.input[1].outcome, Outcome::Correct);\n        assert!(thok.corrected_positions.contains(&1)); // Position 1 should be marked as corrected\n    }\n\n    #[test]\n    fn test_strict_mode_backspace() {\n        let mut thok = Thok::new(\"test\".to_string(), 1, None, true);\n\n        thok.write('t');\n        thok.write('e');\n        assert_eq!(thok.cursor_pos, 2);\n        assert_eq!(thok.input.len(), 2);\n\n        // Test backspace in strict mode\n        thok.backspace();\n        assert_eq!(thok.cursor_pos, 1);\n        assert_eq!(thok.input.len(), 1); // Should remove the input at new cursor position\n    }\n\n    #[test]\n    fn test_normal_mode_vs_strict_mode() {\n        // Test normal mode\n        let mut normal_thok = Thok::new(\"test\".to_string(), 1, None, false);\n        normal_thok.write('x'); // Wrong character\n        assert_eq!(normal_thok.cursor_pos, 1); // Cursor advances even with wrong char\n\n        // Test strict mode\n        let mut strict_thok = Thok::new(\"test\".to_string(), 1, None, true);\n        strict_thok.write('x'); // Wrong character\n        assert_eq!(strict_thok.cursor_pos, 0); // Cursor doesn't advance with wrong char\n    }\n}\n","traces":[{"line":51,"address":[],"length":0,"stats":{"Line":48}},{"line":57,"address":[],"length":0,"stats":{"Line":48}},{"line":60,"address":[],"length":0,"stats":{"Line":48}},{"line":61,"address":[],"length":0,"stats":{"Line":48}},{"line":62,"address":[],"length":0,"stats":{"Line":48}},{"line":74,"address":[],"length":0,"stats":{"Line":48}},{"line":78,"address":[],"length":0,"stats":{"Line":1}},{"line":79,"address":[],"length":0,"stats":{"Line":1}},{"line":80,"address":[],"length":0,"stats":{"Line":1}},{"line":83,"address":[],"length":0,"stats":{"Line":51}},{"line":84,"address":[],"length":0,"stats":{"Line":51}},{"line":87,"address":[],"length":0,"stats":{"Line":40}},{"line":88,"address":[],"length":0,"stats":{"Line":79}},{"line":89,"address":[],"length":0,"stats":{"Line":39}},{"line":93,"address":[],"length":0,"stats":{"Line":4}},{"line":94,"address":[],"length":0,"stats":{"Line":8}},{"line":95,"address":[],"length":0,"stats":{"Line":4}},{"line":99,"address":[],"length":0,"stats":{"Line":6}},{"line":100,"address":[],"length":0,"stats":{"Line":6}},{"line":101,"address":[],"length":0,"stats":{"Line":6}},{"line":104,"address":[],"length":0,"stats":{"Line":34}},{"line":107,"address":[],"length":0,"stats":{"Line":6}},{"line":109,"address":[],"length":0,"stats":{"Line":6}},{"line":111,"address":[],"length":0,"stats":{"Line":6}},{"line":114,"address":[],"length":0,"stats":{"Line":27}},{"line":115,"address":[],"length":0,"stats":{"Line":21}},{"line":116,"address":[],"length":0,"stats":{"Line":21}},{"line":117,"address":[],"length":0,"stats":{"Line":21}},{"line":118,"address":[],"length":0,"stats":{"Line":21}},{"line":119,"address":[],"length":0,"stats":{"Line":21}},{"line":121,"address":[],"length":0,"stats":{"Line":23}},{"line":122,"address":[],"length":0,"stats":{"Line":2}},{"line":123,"address":[],"length":0,"stats":{"Line":21}},{"line":124,"address":[],"length":0,"stats":{"Line":45}},{"line":126,"address":[],"length":0,"stats":{"Line":15}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":4}},{"line":134,"address":[],"length":0,"stats":{"Line":21}},{"line":135,"address":[],"length":0,"stats":{"Line":21}},{"line":138,"address":[],"length":0,"stats":{"Line":18}},{"line":139,"address":[],"length":0,"stats":{"Line":13}},{"line":142,"address":[],"length":0,"stats":{"Line":6}},{"line":145,"address":[],"length":0,"stats":{"Line":18}},{"line":146,"address":[],"length":0,"stats":{"Line":13}},{"line":149,"address":[],"length":0,"stats":{"Line":7}},{"line":150,"address":[],"length":0,"stats":{"Line":1}},{"line":152,"address":[],"length":0,"stats":{"Line":5}},{"line":155,"address":[],"length":0,"stats":{"Line":6}},{"line":157,"address":[],"length":0,"stats":{"Line":18}},{"line":163,"address":[],"length":0,"stats":{"Line":11}},{"line":164,"address":[],"length":0,"stats":{"Line":5}},{"line":166,"address":[],"length":0,"stats":{"Line":1}},{"line":168,"address":[],"length":0,"stats":{"Line":6}},{"line":170,"address":[],"length":0,"stats":{"Line":6}},{"line":173,"address":[],"length":0,"stats":{"Line":12}},{"line":179,"address":[],"length":0,"stats":{"Line":4}},{"line":180,"address":[],"length":0,"stats":{"Line":4}},{"line":182,"address":[],"length":0,"stats":{"Line":1}},{"line":183,"address":[],"length":0,"stats":{"Line":1}},{"line":185,"address":[],"length":0,"stats":{"Line":2}},{"line":186,"address":[],"length":0,"stats":{"Line":1}},{"line":191,"address":[],"length":0,"stats":{"Line":5}},{"line":192,"address":[],"length":0,"stats":{"Line":2}},{"line":193,"address":[],"length":0,"stats":{"Line":2}},{"line":198,"address":[],"length":0,"stats":{"Line":19}},{"line":199,"address":[],"length":0,"stats":{"Line":19}},{"line":202,"address":[],"length":0,"stats":{"Line":7}},{"line":203,"address":[],"length":0,"stats":{"Line":7}},{"line":206,"address":[],"length":0,"stats":{"Line":41}},{"line":207,"address":[],"length":0,"stats":{"Line":82}},{"line":209,"address":[],"length":0,"stats":{"Line":6}},{"line":211,"address":[],"length":0,"stats":{"Line":35}},{"line":214,"address":[],"length":0,"stats":{"Line":74}},{"line":215,"address":[],"length":0,"stats":{"Line":15}},{"line":218,"address":[],"length":0,"stats":{"Line":41}},{"line":219,"address":[],"length":0,"stats":{"Line":41}},{"line":220,"address":[],"length":0,"stats":{"Line":82}},{"line":221,"address":[],"length":0,"stats":{"Line":34}},{"line":223,"address":[],"length":0,"stats":{"Line":7}},{"line":227,"address":[],"length":0,"stats":{"Line":89}},{"line":230,"address":[],"length":0,"stats":{"Line":34}},{"line":234,"address":[],"length":0,"stats":{"Line":82}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":41}},{"line":259,"address":[],"length":0,"stats":{"Line":6}},{"line":261,"address":[],"length":0,"stats":{"Line":8}},{"line":262,"address":[],"length":0,"stats":{"Line":1}},{"line":265,"address":[],"length":0,"stats":{"Line":5}},{"line":266,"address":[],"length":0,"stats":{"Line":1}},{"line":270,"address":[],"length":0,"stats":{"Line":5}},{"line":271,"address":[],"length":0,"stats":{"Line":1}},{"line":272,"address":[],"length":0,"stats":{"Line":1}},{"line":273,"address":[],"length":0,"stats":{"Line":1}},{"line":274,"address":[],"length":0,"stats":{"Line":1}},{"line":275,"address":[],"length":0,"stats":{"Line":1}},{"line":279,"address":[],"length":0,"stats":{"Line":3}},{"line":280,"address":[],"length":0,"stats":{"Line":3}},{"line":281,"address":[],"length":0,"stats":{"Line":3}},{"line":282,"address":[],"length":0,"stats":{"Line":3}},{"line":283,"address":[],"length":0,"stats":{"Line":3}},{"line":287,"address":[],"length":0,"stats":{"Line":4}},{"line":290,"address":[],"length":0,"stats":{"Line":2}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":2}},{"line":300,"address":[],"length":0,"stats":{"Line":2}},{"line":301,"address":[],"length":0,"stats":{"Line":2}},{"line":302,"address":[],"length":0,"stats":{"Line":2}},{"line":303,"address":[],"length":0,"stats":{"Line":2}},{"line":310,"address":[],"length":0,"stats":{"Line":35}},{"line":311,"address":[],"length":0,"stats":{"Line":35}},{"line":312,"address":[],"length":0,"stats":{"Line":35}},{"line":313,"address":[],"length":0,"stats":{"Line":35}},{"line":314,"address":[],"length":0,"stats":{"Line":35}},{"line":315,"address":[],"length":0,"stats":{"Line":35}},{"line":316,"address":[],"length":0,"stats":{"Line":35}},{"line":319,"address":[],"length":0,"stats":{"Line":35}},{"line":323,"address":[],"length":0,"stats":{"Line":41}},{"line":326,"address":[],"length":0,"stats":{"Line":2}},{"line":327,"address":[],"length":0,"stats":{"Line":2}},{"line":330,"address":[],"length":0,"stats":{"Line":17}},{"line":331,"address":[],"length":0,"stats":{"Line":17}},{"line":332,"address":[],"length":0,"stats":{"Line":15}},{"line":335,"address":[],"length":0,"stats":{"Line":6}},{"line":336,"address":[],"length":0,"stats":{"Line":12}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":6}},{"line":345,"address":[],"length":0,"stats":{"Line":6}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":6}},{"line":359,"address":[],"length":0,"stats":{"Line":6}},{"line":360,"address":[],"length":0,"stats":{"Line":6}},{"line":362,"address":[],"length":0,"stats":{"Line":6}},{"line":363,"address":[],"length":0,"stats":{"Line":6}},{"line":364,"address":[],"length":0,"stats":{"Line":6}},{"line":365,"address":[],"length":0,"stats":{"Line":6}},{"line":373,"address":[],"length":0,"stats":{"Line":6}},{"line":377,"address":[],"length":0,"stats":{"Line":3}},{"line":378,"address":[],"length":0,"stats":{"Line":6}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":2}},{"line":387,"address":[],"length":0,"stats":{"Line":4}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":2}},{"line":396,"address":[],"length":0,"stats":{"Line":4}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":3}},{"line":405,"address":[],"length":0,"stats":{"Line":6}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":7}},{"line":414,"address":[],"length":0,"stats":{"Line":14}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":2}},{"line":423,"address":[],"length":0,"stats":{"Line":2}},{"line":427,"address":[],"length":0,"stats":{"Line":1}},{"line":428,"address":[],"length":0,"stats":{"Line":1}}],"covered":145,"coverable":161},{"path":["/","Users","martintrojer","hacking","thokr","src","ui.rs"],"content":"use ratatui::{\n    buffer::Buffer,\n    layout::{Alignment, Constraint, Direction, Layout, Rect},\n    style::{Color, Modifier, Style},\n    text::{Line, Span},\n    widgets::{Axis, Chart, Dataset, GraphType, Paragraph, Widget, Wrap},\n};\nuse unicode_width::UnicodeWidthStr;\nuse webbrowser::Browser;\n\nuse crate::thok::{Outcome, Thok};\n\nconst HORIZONTAL_MARGIN: u16 = 5;\nconst VERTICAL_MARGIN: u16 = 2;\n\nimpl Widget for &Thok {\n    fn render(self, area: Rect, buf: &mut Buffer) {\n        // styles\n        let bold_style = Style::default().add_modifier(Modifier::BOLD);\n\n        let green_bold_style = Style::default().patch(bold_style).fg(Color::Green);\n        let red_bold_style = Style::default().patch(bold_style).fg(Color::Red);\n\n        let dim_bold_style = Style::default()\n            .patch(bold_style)\n            .add_modifier(Modifier::DIM);\n\n        let underlined_dim_bold_style = Style::default()\n            .patch(dim_bold_style)\n            .add_modifier(Modifier::UNDERLINED);\n\n        let italic_style = Style::default().add_modifier(Modifier::ITALIC);\n\n        let magenta_style = Style::default().fg(Color::Magenta);\n\n        match !self.has_finished() {\n            true => {\n                let max_chars_per_line = area.width - (HORIZONTAL_MARGIN * 2);\n                let mut prompt_occupied_lines =\n                    ((self.prompt.width() as f64 / max_chars_per_line as f64).ceil() + 1.0) as u16;\n\n                let time_left_lines = if self.number_of_secs.is_some() { 2 } else { 0 };\n\n                if self.prompt.width() <= max_chars_per_line as usize {\n                    prompt_occupied_lines = 1;\n                }\n\n                let chunks = Layout::default()\n                    .direction(Direction::Vertical)\n                    .horizontal_margin(HORIZONTAL_MARGIN)\n                    .constraints(\n                        [\n                            Constraint::Length(\n                                ((area.height as f64 - prompt_occupied_lines as f64) / 2.0) as u16,\n                            ),\n                            Constraint::Length(time_left_lines),\n                            Constraint::Length(prompt_occupied_lines),\n                            Constraint::Length(\n                                ((area.height as f64 - prompt_occupied_lines as f64) / 2.0) as u16,\n                            ),\n                        ]\n                        .as_ref(),\n                    )\n                    .split(area);\n\n                let mut spans = self\n                    .input\n                    .iter()\n                    .enumerate()\n                    .map(|(idx, input)| {\n                        let expected = self.get_expected_char(idx).to_string();\n\n                        match input.outcome {\n                            Outcome::Incorrect => Span::styled(\n                                match expected.as_str() {\n                                    \" \" => \"\".to_owned(),\n                                    _ => expected,\n                                },\n                                red_bold_style,\n                            ),\n                            Outcome::Correct => {\n                                // In strict mode, show corrected positions with a different color\n                                if self.strict_mode && self.corrected_positions.contains(&idx) {\n                                    // Show corrected errors with orange color (much more distinct from green)\n                                    Span::styled(\n                                        expected,\n                                        Style::default()\n                                            .patch(bold_style)\n                                            .fg(Color::Rgb(255, 165, 0)),\n                                    )\n                                } else {\n                                    Span::styled(expected, green_bold_style)\n                                }\n                            }\n                        }\n                    })\n                    .collect::<Vec<Span>>();\n\n                spans.push(Span::styled(\n                    self.get_expected_char(self.cursor_pos).to_string(),\n                    underlined_dim_bold_style,\n                ));\n\n                spans.push(Span::styled(\n                    self.prompt[(self.cursor_pos + 1)..self.prompt.len()].to_string(),\n                    dim_bold_style,\n                ));\n\n                let widget = Paragraph::new(Line::from(spans))\n                    .alignment(if prompt_occupied_lines == 1 {\n                        // when the prompt is small enough to fit on one line\n                        // centering the text gives a nice zen feeling\n                        Alignment::Center\n                    } else {\n                        Alignment::Left\n                    })\n                    .wrap(Wrap { trim: true });\n\n                widget.render(chunks[2], buf);\n\n                if self.seconds_remaining.is_some() {\n                    let timer = Paragraph::new(Span::styled(\n                        format!(\"{:.1}\", self.seconds_remaining.unwrap()),\n                        dim_bold_style,\n                    ))\n                    .alignment(Alignment::Center);\n\n                    timer.render(chunks[1], buf);\n                }\n            }\n            false => {\n                let chunks = Layout::default()\n                    .direction(Direction::Vertical)\n                    .horizontal_margin(HORIZONTAL_MARGIN)\n                    .vertical_margin(VERTICAL_MARGIN)\n                    .constraints(\n                        [\n                            Constraint::Min(1),\n                            Constraint::Length(1),\n                            Constraint::Length(1), // for padding\n                            Constraint::Length(1),\n                        ]\n                        .as_ref(),\n                    )\n                    .split(area);\n\n                let mut highest_wpm = 0.0;\n\n                for ts in &self.wpm_coords {\n                    if ts.1 > highest_wpm {\n                        highest_wpm = ts.1;\n                    }\n                }\n\n                let datasets = vec![Dataset::default()\n                    .marker(ratatui::symbols::Marker::Braille)\n                    .style(magenta_style)\n                    .graph_type(GraphType::Line)\n                    .data(&self.wpm_coords)];\n\n                let mut overall_duration = match self.wpm_coords.last() {\n                    Some(x) => x.0,\n                    _ => self.seconds_remaining.unwrap_or(1.0),\n                };\n\n                overall_duration = if overall_duration < 1.0 {\n                    1.0\n                } else {\n                    overall_duration\n                };\n\n                let chart = Chart::new(datasets)\n                    .x_axis(\n                        Axis::default()\n                            .title(\"seconds\")\n                            .bounds([1.0, overall_duration])\n                            .labels(vec![\n                                Span::styled(\"1\", bold_style),\n                                Span::styled(format!(\"{:.2}\", overall_duration), bold_style),\n                            ]),\n                    )\n                    .y_axis(\n                        Axis::default()\n                            .title(\"wpm\")\n                            .bounds([0.0, highest_wpm.round()])\n                            .labels(vec![\n                                Span::styled(\"0\", bold_style),\n                                Span::styled(format!(\"{}\", highest_wpm.round()), bold_style),\n                            ]),\n                    );\n\n                chart.render(chunks[0], buf);\n\n                let stats = Paragraph::new(Span::styled(\n                    format!(\n                        \"{} wpm   {}% acc   {:.2} sd\",\n                        self.wpm, self.accuracy, self.std_dev\n                    ),\n                    bold_style,\n                ))\n                .alignment(Alignment::Center);\n\n                stats.render(chunks[1], buf);\n\n                let legend = Paragraph::new(Span::styled(\n                    String::from(if Browser::is_available() {\n                        \"(r)etry / (n)ew / (s)tats / (t)weet / (esc)ape\"\n                    } else {\n                        \"(r)etry / (n)ew / (s)tats / (esc)ape\"\n                    }),\n                    italic_style,\n                ));\n\n                legend.render(chunks[3], buf);\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::thok::{Input, Outcome, Thok};\n    use ratatui::{buffer::Buffer, layout::Rect};\n    use std::time::SystemTime;\n\n    fn create_test_thok(prompt: &str, finished: bool) -> Thok {\n        let mut thok = Thok::new(prompt.to_string(), 1, None, false);\n\n        if finished {\n            for c in prompt.chars() {\n                thok.input.push(Input {\n                    char: c,\n                    outcome: Outcome::Correct,\n                    timestamp: SystemTime::now(),\n                    keypress_start: None,\n                });\n            }\n            thok.cursor_pos = prompt.len();\n            thok.wpm = 42.0;\n            thok.accuracy = 95.0;\n            thok.std_dev = 2.5;\n            thok.wpm_coords = vec![(1.0, 20.0), (2.0, 35.0), (3.0, 42.0)];\n        }\n\n        thok\n    }\n\n    #[test]\n    fn test_ui_widget_in_progress() {\n        let thok = create_test_thok(\"hello world\", false);\n        let area = Rect::new(0, 0, 80, 24);\n        let mut buffer = Buffer::empty(area);\n\n        (&thok).render(area, &mut buffer);\n\n        let rendered = buffer\n            .content()\n            .iter()\n            .map(|c| c.symbol())\n            .collect::<String>();\n        assert!(rendered.contains(\"hello world\") || !rendered.trim().is_empty());\n    }\n\n    #[test]\n    fn test_ui_widget_finished() {\n        let thok = create_test_thok(\"test\", true);\n        let area = Rect::new(0, 0, 80, 24);\n        let mut buffer = Buffer::empty(area);\n\n        (&thok).render(area, &mut buffer);\n\n        let rendered = buffer\n            .content()\n            .iter()\n            .map(|c| c.symbol())\n            .collect::<String>();\n\n        assert!(rendered.contains(\"42\") || rendered.contains(\"95\") || !rendered.trim().is_empty());\n    }\n\n    #[test]\n    fn test_ui_widget_with_time_limit() {\n        let mut thok = Thok::new(\"test\".to_string(), 1, Some(30.0), false);\n        thok.seconds_remaining = Some(25.5);\n\n        let area = Rect::new(0, 0, 80, 24);\n        let mut buffer = Buffer::empty(area);\n\n        (&thok).render(area, &mut buffer);\n\n        let rendered = buffer\n            .content()\n            .iter()\n            .map(|c| c.symbol())\n            .collect::<String>();\n        assert!(\n            rendered.contains(\"25.5\") || rendered.contains(\"test\") || !rendered.trim().is_empty()\n        );\n    }\n\n    #[test]\n    fn test_ui_widget_small_area() {\n        let thok = create_test_thok(\"hello\", false);\n        let area = Rect::new(0, 0, 20, 5);\n        let mut buffer = Buffer::empty(area);\n\n        (&thok).render(area, &mut buffer);\n\n        assert!(*buffer.area() == area);\n    }\n\n    #[test]\n    fn test_ui_widget_with_incorrect_input() {\n        let mut thok = Thok::new(\"test\".to_string(), 1, None, false);\n\n        thok.input.push(Input {\n            char: 't',\n            outcome: Outcome::Correct,\n            timestamp: SystemTime::now(),\n            keypress_start: None,\n        });\n        thok.input.push(Input {\n            char: 'x',\n            outcome: Outcome::Incorrect,\n            timestamp: SystemTime::now(),\n            keypress_start: None,\n        });\n        thok.cursor_pos = 2;\n\n        let area = Rect::new(0, 0, 80, 24);\n        let mut buffer = Buffer::empty(area);\n\n        (&thok).render(area, &mut buffer);\n\n        assert!(*buffer.area() == area);\n    }\n\n    #[test]\n    fn test_ui_constants() {\n        assert_eq!(HORIZONTAL_MARGIN, 5);\n        assert_eq!(VERTICAL_MARGIN, 2);\n    }\n\n    #[test]\n    fn test_ui_widget_finished_with_browser_available() {\n        let thok = create_test_thok(\"test\", true);\n        let area = Rect::new(0, 0, 80, 24);\n        let mut buffer = Buffer::empty(area);\n\n        (&thok).render(area, &mut buffer);\n\n        let rendered = buffer\n            .content()\n            .iter()\n            .map(|c| c.symbol())\n            .collect::<String>();\n\n        if Browser::is_available() {\n            assert!(\n                rendered.contains(\"(t)weet\")\n                    || rendered.contains(\"(r)etry\")\n                    || rendered.contains(\"(n)ew\")\n                    || rendered.contains(\"(s)tats\")\n                    || rendered.contains(\"(esc)ape\")\n                    || !rendered.trim().is_empty()\n            );\n        } else {\n            assert!(\n                rendered.contains(\"(r)etry\")\n                    || rendered.contains(\"(n)ew\")\n                    || rendered.contains(\"(s)tats\")\n                    || rendered.contains(\"(esc)ape\")\n                    || !rendered.trim().is_empty()\n            );\n        }\n    }\n\n    #[test]\n    fn test_ui_widget_large_prompt() {\n        let large_prompt = \"This is a very long prompt that should wrap across multiple lines when rendered in the terminal interface to test the text wrapping functionality\";\n        let thok = create_test_thok(large_prompt, false);\n        let area = Rect::new(0, 0, 40, 20);\n        let mut buffer = Buffer::empty(area);\n\n        (&thok).render(area, &mut buffer);\n\n        assert!(*buffer.area() == area);\n    }\n\n    #[test]\n    fn test_ui_widget_empty_prompt() {\n        let thok = create_test_thok(\"\", false);\n        let area = Rect::new(0, 0, 80, 24);\n        let mut buffer = Buffer::empty(area);\n\n        (&thok).render(area, &mut buffer);\n\n        assert!(*buffer.area() == area);\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":8}},{"line":19,"address":[],"length":0,"stats":{"Line":8}},{"line":21,"address":[],"length":0,"stats":{"Line":8}},{"line":22,"address":[],"length":0,"stats":{"Line":8}},{"line":24,"address":[],"length":0,"stats":{"Line":8}},{"line":25,"address":[],"length":0,"stats":{"Line":8}},{"line":26,"address":[],"length":0,"stats":{"Line":8}},{"line":28,"address":[],"length":0,"stats":{"Line":8}},{"line":29,"address":[],"length":0,"stats":{"Line":8}},{"line":30,"address":[],"length":0,"stats":{"Line":8}},{"line":32,"address":[],"length":0,"stats":{"Line":8}},{"line":34,"address":[],"length":0,"stats":{"Line":8}},{"line":36,"address":[],"length":0,"stats":{"Line":8}},{"line":38,"address":[],"length":0,"stats":{"Line":5}},{"line":39,"address":[],"length":0,"stats":{"Line":5}},{"line":40,"address":[],"length":0,"stats":{"Line":5}},{"line":42,"address":[],"length":0,"stats":{"Line":15}},{"line":44,"address":[],"length":0,"stats":{"Line":9}},{"line":45,"address":[],"length":0,"stats":{"Line":4}},{"line":48,"address":[],"length":0,"stats":{"Line":5}},{"line":49,"address":[],"length":0,"stats":{"Line":5}},{"line":50,"address":[],"length":0,"stats":{"Line":5}},{"line":53,"address":[],"length":0,"stats":{"Line":5}},{"line":54,"address":[],"length":0,"stats":{"Line":5}},{"line":56,"address":[],"length":0,"stats":{"Line":5}},{"line":57,"address":[],"length":0,"stats":{"Line":5}},{"line":58,"address":[],"length":0,"stats":{"Line":5}},{"line":59,"address":[],"length":0,"stats":{"Line":5}},{"line":62,"address":[],"length":0,"stats":{"Line":5}},{"line":64,"address":[],"length":0,"stats":{"Line":5}},{"line":66,"address":[],"length":0,"stats":{"Line":5}},{"line":67,"address":[],"length":0,"stats":{"Line":5}},{"line":70,"address":[],"length":0,"stats":{"Line":7}},{"line":71,"address":[],"length":0,"stats":{"Line":2}},{"line":73,"address":[],"length":0,"stats":{"Line":2}},{"line":75,"address":[],"length":0,"stats":{"Line":1}},{"line":76,"address":[],"length":0,"stats":{"Line":1}},{"line":77,"address":[],"length":0,"stats":{"Line":1}},{"line":79,"address":[],"length":0,"stats":{"Line":1}},{"line":83,"address":[],"length":0,"stats":{"Line":1}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":1}},{"line":99,"address":[],"length":0,"stats":{"Line":5}},{"line":100,"address":[],"length":0,"stats":{"Line":5}},{"line":101,"address":[],"length":0,"stats":{"Line":5}},{"line":104,"address":[],"length":0,"stats":{"Line":5}},{"line":105,"address":[],"length":0,"stats":{"Line":5}},{"line":106,"address":[],"length":0,"stats":{"Line":5}},{"line":109,"address":[],"length":0,"stats":{"Line":10}},{"line":110,"address":[],"length":0,"stats":{"Line":5}},{"line":113,"address":[],"length":0,"stats":{"Line":4}},{"line":115,"address":[],"length":0,"stats":{"Line":1}},{"line":117,"address":[],"length":0,"stats":{"Line":5}},{"line":119,"address":[],"length":0,"stats":{"Line":5}},{"line":121,"address":[],"length":0,"stats":{"Line":6}},{"line":122,"address":[],"length":0,"stats":{"Line":1}},{"line":123,"address":[],"length":0,"stats":{"Line":1}},{"line":124,"address":[],"length":0,"stats":{"Line":1}},{"line":126,"address":[],"length":0,"stats":{"Line":1}},{"line":128,"address":[],"length":0,"stats":{"Line":1}},{"line":132,"address":[],"length":0,"stats":{"Line":3}},{"line":133,"address":[],"length":0,"stats":{"Line":3}},{"line":134,"address":[],"length":0,"stats":{"Line":3}},{"line":135,"address":[],"length":0,"stats":{"Line":3}},{"line":138,"address":[],"length":0,"stats":{"Line":3}},{"line":139,"address":[],"length":0,"stats":{"Line":3}},{"line":140,"address":[],"length":0,"stats":{"Line":3}},{"line":141,"address":[],"length":0,"stats":{"Line":3}},{"line":143,"address":[],"length":0,"stats":{"Line":3}},{"line":145,"address":[],"length":0,"stats":{"Line":3}},{"line":147,"address":[],"length":0,"stats":{"Line":3}},{"line":149,"address":[],"length":0,"stats":{"Line":15}},{"line":150,"address":[],"length":0,"stats":{"Line":6}},{"line":151,"address":[],"length":0,"stats":{"Line":6}},{"line":162,"address":[],"length":0,"stats":{"Line":2}},{"line":163,"address":[],"length":0,"stats":{"Line":1}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":3}},{"line":207,"address":[],"length":0,"stats":{"Line":3}},{"line":209,"address":[],"length":0,"stats":{"Line":0}}],"covered":77,"coverable":84},{"path":["/","Users","martintrojer","hacking","thokr","src","util.rs"],"content":"pub fn mean(data: &[f64]) -> Option<f64> {\n    let sum = data.iter().sum::<f64>();\n    let count = data.len();\n\n    match count {\n        positive if positive > 0 => Some(sum / count as f64),\n        _ => None,\n    }\n}\n\npub fn std_dev(data: &[f64]) -> Option<f64> {\n    match (mean(data), data.len()) {\n        (Some(data_mean), count) if count > 0 => {\n            let variance = data\n                .iter()\n                .map(|value| {\n                    let diff = data_mean - *value;\n\n                    diff * diff\n                })\n                .sum::<f64>()\n                / count as f64;\n\n            Some(variance.sqrt())\n        }\n        _ => None,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_mean() {\n        assert_eq!(mean(&[10., 20., 30., 15., 22.]), Some(19.4));\n        assert_eq!(mean(&[15., 7., 55., 12., 4.]), Some(18.6));\n    }\n\n    #[test]\n    fn test_mean_single_value() {\n        assert_eq!(mean(&[42.0]), Some(42.0));\n    }\n\n    #[test]\n    fn test_mean_empty_slice() {\n        assert_eq!(mean(&[]), None);\n    }\n\n    #[test]\n    fn test_mean_negative_values() {\n        assert_eq!(mean(&[-5.0, -10.0, -15.0]), Some(-10.0));\n    }\n\n    #[test]\n    fn test_mean_mixed_values() {\n        assert_eq!(mean(&[-10.0, 0.0, 10.0]), Some(0.0));\n    }\n\n    #[test]\n    fn test_std_dev() {\n        assert_eq!(\n            std_dev(&[100., 120., 90., 102., 94.]),\n            Some(10.322790320451151)\n        );\n        assert_eq!(std_dev(&[15., 7., 55.]), Some(20.997354330698162));\n    }\n\n    #[test]\n    fn test_std_dev_single_value() {\n        assert_eq!(std_dev(&[42.0]), Some(0.0));\n    }\n\n    #[test]\n    fn test_std_dev_empty_slice() {\n        assert_eq!(std_dev(&[]), None);\n    }\n\n    #[test]\n    fn test_std_dev_identical_values() {\n        assert_eq!(std_dev(&[5.0, 5.0, 5.0, 5.0]), Some(0.0));\n    }\n\n    #[test]\n    fn test_std_dev_negative_values() {\n        let result = std_dev(&[-10.0, -5.0, -15.0]);\n        assert!(result.is_some());\n        assert!((result.unwrap() - 4.08248290463863).abs() < 1e-10);\n    }\n}\n","traces":[{"line":1,"address":[],"length":0,"stats":{"Line":13}},{"line":2,"address":[],"length":0,"stats":{"Line":13}},{"line":3,"address":[],"length":0,"stats":{"Line":13}},{"line":5,"address":[],"length":0,"stats":{"Line":13}},{"line":6,"address":[],"length":0,"stats":{"Line":35}},{"line":7,"address":[],"length":0,"stats":{"Line":2}},{"line":11,"address":[],"length":0,"stats":{"Line":7}},{"line":12,"address":[],"length":0,"stats":{"Line":7}},{"line":13,"address":[],"length":0,"stats":{"Line":18}},{"line":14,"address":[],"length":0,"stats":{"Line":6}},{"line":15,"address":[],"length":0,"stats":{"Line":6}},{"line":16,"address":[],"length":0,"stats":{"Line":23}},{"line":17,"address":[],"length":0,"stats":{"Line":17}},{"line":19,"address":[],"length":0,"stats":{"Line":17}},{"line":21,"address":[],"length":0,"stats":{"Line":6}},{"line":22,"address":[],"length":0,"stats":{"Line":6}},{"line":24,"address":[],"length":0,"stats":{"Line":6}},{"line":26,"address":[],"length":0,"stats":{"Line":1}}],"covered":18,"coverable":18},{"path":["/","Users","martintrojer","hacking","thokr","src","word_generator.rs"],"content":"use crate::{\n    language::{\n        CompositeFormatter, IntelligentSelector, Language, RandomSelector, SubstitutionSelector,\n        WordSelector,\n    },\n    stats::StatsDb,\n    SupportedLanguage,\n};\nuse std::collections::HashMap;\n\n/// Configuration for word generation\n#[derive(Debug, Clone)]\npub struct WordGenConfig {\n    pub number_of_words: usize,\n    pub number_of_sentences: Option<usize>,\n    pub custom_prompt: Option<String>,\n    pub language: SupportedLanguage,\n    pub random_words: bool,\n    pub substitute: bool,\n    pub capitalize: bool,\n    pub symbols: bool,\n}\n\n/// Handles all word and prompt generation logic\npub struct WordGenerator {\n    config: WordGenConfig,\n}\n\nimpl WordGenerator {\n    pub fn new(config: WordGenConfig) -> Self {\n        Self { config }\n    }\n\n    /// Generate a complete prompt based on the configuration\n    pub fn generate_prompt(&self) -> (String, usize) {\n        if let Some(ref custom_prompt) = self.config.custom_prompt {\n            return (custom_prompt.clone(), self.config.number_of_words);\n        }\n\n        if let Some(sentence_count) = self.config.number_of_sentences {\n            return self.generate_sentences(sentence_count);\n        }\n\n        self.generate_words()\n    }\n\n    /// Generate sentences using cgisf\n    fn generate_sentences(&self, count: usize) -> (String, usize) {\n        let language = self.config.language.as_lang();\n        let (sentences, word_count) = language.get_random_sentence(count);\n        (sentences.join(\"\"), word_count)\n    }\n\n    /// Generate words based on selection strategy and apply formatting\n    fn generate_words(&self) -> (String, usize) {\n        let language = self.config.language.as_lang();\n\n        // Step 1: Select words based on strategy\n        let words = self.select_words(&language);\n\n        // Step 2: Apply formatting using the new formatter system\n        let formatter =\n            CompositeFormatter::build_from_flags(self.config.capitalize, self.config.symbols);\n        let formatted_text = formatter.format(words);\n\n        (formatted_text, self.config.number_of_words)\n    }\n\n    /// Select words based on the configured strategy\n    fn select_words(&self, language: &Language) -> Vec<String> {\n        // Load character statistics for intelligent/substitution modes\n        let char_difficulties = match StatsDb::new() {\n            Ok(stats_db) => stats_db.get_character_difficulties().unwrap_or_default(),\n            Err(_) => HashMap::new(),\n        };\n\n        // Choose the appropriate selector based on configuration\n        let selector: Box<dyn WordSelector> = if self.config.random_words {\n            Box::new(RandomSelector)\n        } else if self.config.substitute {\n            Box::new(SubstitutionSelector)\n        } else {\n            Box::new(IntelligentSelector)\n        };\n\n        selector.select_words(language, self.config.number_of_words, &char_difficulties)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn create_test_config() -> WordGenConfig {\n        WordGenConfig {\n            number_of_words: 5,\n            number_of_sentences: None,\n            custom_prompt: None,\n            language: SupportedLanguage::English,\n            random_words: false,\n            substitute: false,\n            capitalize: false,\n            symbols: false,\n        }\n    }\n\n    #[test]\n    fn test_custom_prompt() {\n        let mut config = create_test_config();\n        config.custom_prompt = Some(\"custom test prompt\".to_string());\n\n        let generator = WordGenerator::new(config);\n        let (prompt, word_count) = generator.generate_prompt();\n\n        assert_eq!(prompt, \"custom test prompt\");\n        assert_eq!(word_count, 5);\n    }\n\n    #[test]\n    fn test_sentence_generation() {\n        let mut config = create_test_config();\n        config.number_of_sentences = Some(2);\n\n        let generator = WordGenerator::new(config);\n        let (prompt, word_count) = generator.generate_prompt();\n\n        assert!(!prompt.is_empty());\n        assert!(word_count > 0);\n    }\n\n    #[test]\n    fn test_word_generation_random() {\n        let mut config = create_test_config();\n        config.random_words = true;\n\n        let generator = WordGenerator::new(config);\n        let (prompt, word_count) = generator.generate_prompt();\n\n        assert!(!prompt.is_empty());\n        assert_eq!(word_count, 5);\n        // Should be space-separated words\n        assert!(prompt.contains(' '));\n    }\n\n    #[test]\n    fn test_word_generation_with_capitalization() {\n        let mut config = create_test_config();\n        config.capitalize = true;\n\n        let generator = WordGenerator::new(config);\n        let (prompt, _) = generator.generate_prompt();\n\n        assert!(!prompt.is_empty());\n        // Should start with capital letter\n        assert!(prompt.chars().next().unwrap().is_uppercase());\n    }\n\n    #[test]\n    fn test_word_generation_with_substitution() {\n        let mut config = create_test_config();\n        config.substitute = true;\n\n        let generator = WordGenerator::new(config);\n        let (prompt, word_count) = generator.generate_prompt();\n\n        assert!(!prompt.is_empty());\n        assert_eq!(word_count, 5);\n    }\n\n    #[test]\n    fn test_word_generation_combined_flags() {\n        let mut config = create_test_config();\n        config.substitute = true;\n        config.capitalize = true;\n        config.symbols = true;\n\n        let generator = WordGenerator::new(config);\n        let (prompt, word_count) = generator.generate_prompt();\n\n        assert!(!prompt.is_empty());\n        assert_eq!(word_count, 5);\n        // Should have capitalization (first alphabetic character should be uppercase)\n        let first_alpha_char = prompt.chars().find(|c| c.is_alphabetic());\n        if let Some(first_char) = first_alpha_char {\n            assert!(\n                first_char.is_uppercase(),\n                \"First alphabetic character should be uppercase. Generated prompt: '{}'\",\n                prompt\n            );\n        }\n    }\n\n    #[test]\n    fn test_word_generation_intelligent_selection() {\n        let mut config = create_test_config();\n        config.random_words = false; // Use intelligent selection\n\n        let generator = WordGenerator::new(config);\n        let (prompt, word_count) = generator.generate_prompt();\n\n        assert!(!prompt.is_empty());\n        assert_eq!(word_count, 5);\n    }\n\n    #[test]\n    fn test_word_generation_with_symbols_only() {\n        let mut config = create_test_config();\n        config.symbols = true;\n\n        let generator = WordGenerator::new(config);\n        let (prompt, word_count) = generator.generate_prompt();\n\n        assert!(!prompt.is_empty());\n        assert_eq!(word_count, 5);\n        // Should end with punctuation\n        assert!(\n            prompt.ends_with('.')\n                || prompt.ends_with('!')\n                || prompt.ends_with('?')\n                || prompt.ends_with(';')\n                || prompt.ends_with(':')\n                || prompt.ends_with(\"...\")\n        );\n    }\n\n    #[test]\n    fn test_config_conversion() {\n        let config = create_test_config();\n\n        assert_eq!(config.number_of_words, 5);\n        assert_eq!(config.number_of_sentences, None);\n        assert_eq!(config.custom_prompt, None);\n        assert!(!config.random_words);\n        assert!(!config.substitute);\n        assert!(!config.capitalize);\n        assert!(!config.symbols);\n    }\n\n    #[test]\n    fn test_generate_prompt_respects_custom_prompt() {\n        let mut config = create_test_config();\n        config.custom_prompt = Some(\"test custom prompt\".to_string());\n\n        let generator = WordGenerator::new(config.clone());\n        let (prompt, word_count) = generator.generate_prompt();\n\n        assert_eq!(prompt, \"test custom prompt\");\n        assert_eq!(word_count, config.number_of_words);\n    }\n\n    #[test]\n    fn test_priority_order_custom_prompt_over_sentences() {\n        let mut config = create_test_config();\n        config.number_of_sentences = Some(1);\n        config.custom_prompt = Some(\"custom takes priority\".to_string());\n\n        let expected_word_count = config.number_of_words;\n        let generator = WordGenerator::new(config);\n        let (prompt, word_count) = generator.generate_prompt();\n\n        // Custom prompt should take priority over sentences\n        assert_eq!(prompt, \"custom takes priority\");\n        assert_eq!(word_count, expected_word_count);\n    }\n\n    #[test]\n    fn test_sentences_when_no_custom_prompt() {\n        let mut config = create_test_config();\n        config.number_of_sentences = Some(1);\n        config.custom_prompt = None; // No custom prompt\n\n        let generator = WordGenerator::new(config);\n        let (prompt, word_count) = generator.generate_prompt();\n\n        // Should generate sentences when no custom prompt is provided\n        assert!(!prompt.is_empty());\n        assert!(word_count > 0);\n        // Should be sentence-generated content\n        assert_ne!(prompt, \"custom takes priority\");\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":25}},{"line":35,"address":[],"length":0,"stats":{"Line":25}},{"line":36,"address":[],"length":0,"stats":{"Line":32}},{"line":40,"address":[],"length":0,"stats":{"Line":21}},{"line":44,"address":[],"length":0,"stats":{"Line":15}},{"line":48,"address":[],"length":0,"stats":{"Line":3}},{"line":49,"address":[],"length":0,"stats":{"Line":3}},{"line":50,"address":[],"length":0,"stats":{"Line":3}},{"line":51,"address":[],"length":0,"stats":{"Line":3}},{"line":55,"address":[],"length":0,"stats":{"Line":15}},{"line":56,"address":[],"length":0,"stats":{"Line":15}},{"line":59,"address":[],"length":0,"stats":{"Line":15}},{"line":62,"address":[],"length":0,"stats":{"Line":15}},{"line":63,"address":[],"length":0,"stats":{"Line":15}},{"line":64,"address":[],"length":0,"stats":{"Line":15}},{"line":66,"address":[],"length":0,"stats":{"Line":15}},{"line":70,"address":[],"length":0,"stats":{"Line":15}},{"line":72,"address":[],"length":0,"stats":{"Line":30}},{"line":73,"address":[],"length":0,"stats":{"Line":15}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":30}},{"line":79,"address":[],"length":0,"stats":{"Line":1}},{"line":80,"address":[],"length":0,"stats":{"Line":14}},{"line":81,"address":[],"length":0,"stats":{"Line":4}},{"line":83,"address":[],"length":0,"stats":{"Line":10}},{"line":86,"address":[],"length":0,"stats":{"Line":15}}],"covered":25,"coverable":26}],"coverage":63.926940639269404,"covered":700,"coverable":1095}